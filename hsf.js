// Generated by CoffeeScript 1.6.2
(function() {
  "use strict";
  /**
   * <b>HSF</b> это hight speed function (высокоскоростные функции).
   * Функции, ориентированные на скорость выполнения в зависимости от задач.
   * Созданный класс вносит корректировки в прототипы базовых классов и сильно
   * расширяет базовый функционал, позволяя использовать функии со скоростью превосходящей jQuery,
   * но уступающей по кросбраузерности
   * @author Louter
   * @version 0.4.0
   * @changeLog: by 0.1
   *  +getScrollBarWidth
   *  +random
   *  +qsa
   *  +insertAfter, +insertBefore
   *  +clearElement
   *  ~setDrag add dragOver, gragOut, drop and change arguments mix
   *  ~openWin add callback
   * @changeLog: by 0.2
   *  +formToData
   * @changeLog: by 0.3
   *  +removeElement
   *  ~appendChild
   * @changeLog: by 0.4
   *  +setStyle
   *  +getIndexElement
   *  ~createLoaderBubble
   *  ~setMem,buttonClick,hover (return this)
   *  ~retTempStyle
   *  ~load
   *  ~setDrag add touch
   * @changeLog: by 0.5
   *  +setCSSS
   *  +remCSSS
   *  +updateStyleSheetIndex
   *  +createStyleSheet
   *  +Function::bind
   *  ~openWin
   *  ~load
   *  ~log, printLog
   *  ~qsa
   * @changeLog: by 0.5.1
   *  ~updateStyleSheetIndex
   *  ~addEvent
  */

  /**
   * _HSF это контейнер для всех экземпляров класса, но обычно в нём всего 1 экземпляр
   * @type {Object}
   * @private
  */

  var HSF,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window._HSF = {
    get: function(id) {
      return _HSF[id] || null;
    }
  };

  /**
   * Базовый класс содержит методы и переменные
   * @class HSF
   * @type {HSF}
  */


  HSF = (function() {
    /**
     * Сбор объектов для запросов.
     * Необходим для использования установившихся соединений и для образ-я новых
     * @type {Array}
     * @private
    */
    HSF.prototype._rPool = [];

    /**
     * Счётчик для отклучения кэша при AJAX запросах. Может быть выключен через параметр counter:false
     * @type {Number}
     * @private
    */


    HSF.prototype._counter = 0;

    /**
     * Флвг, определяющая включен ли счётчик
     * @type {Boolean}
     * @private
    */


    HSF.prototype._counterEnabled = true;

    /**
     * Кэш для названия браузера.
     * (Надеюсь в процессе работы браузер не сменится внезапно с одного на другой)
     * @type {Object}
     * @private
    */


    HSF.prototype._browser = {
      version: 0,
      name: ""
    };

    /**
     * Флаг, включен ли режим отладки
     * @type {Boolean}
     * @private
    */


    HSF.prototype._debug = false;

    /**
     * id экземпляра для обращения в inline-функциях
     * @type {String}
     * @private
    */


    HSF.prototype._id = '';

    /**
     * Кеш для имён CSS свойств, с префиксами (-mox
     * @type {Object}
     * @private
    */


    HSF.prototype._setUniversalStyleCascade = {};

    /**
     * константа, определяющая, с какими префиксами мы работаем
     * @const
     * @type {Array}
     * @private
    */


    HSF.prototype._stylePrefixes = ['', 'o', 'ms', 'moz', 'webkit'];

    /**
     * Сбор объектов, за которыми происходит слежка изменили ли они свои размеры
     * @type {Array}
     * @private
    */


    HSF.prototype._onResizeCollection = [];

    /**
     * Массив объектов у которых следует следить за изменением размера (их позиции в коллекции)
     * @type {Array}
     * @private
    */


    HSF.prototype._onResizeArray = [];

    /**
     * Дата начала логирования вмилесекундах
     * @type {Number}
     * @private
    */


    HSF.prototype._startLogDate = (new Date()).getTime();

    /**
     * Логи, которые откидываются в console.log, если таковой имеется.
     * @type {Object}
     * @private
    */


    HSF.prototype._stackLog = [];

    /**
     * Названия клавиш и значения их при нажатии по умолчанию. Внутри keyListener переопределяются
     * @type {Object}
     * @private
    */


    HSF.prototype._keyMap = {
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      ctrl: 17,
      alt: 18,
      pauseBreak: 19,
      capsLock: 20,
      escape: 27,
      esc: 27,
      pageUp: 33,
      pageDown: 34,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      insert: 45,
      "delete": 46,
      0: 48,
      1: 49,
      2: 50,
      3: 51,
      4: 52,
      5: 53,
      6: 54,
      7: 55,
      8: 56,
      9: 57,
      a: 65,
      b: 66,
      c: 67,
      d: 68,
      e: 69,
      f: 70,
      g: 71,
      h: 72,
      i: 73,
      j: 74,
      k: 75,
      l: 76,
      m: 77,
      n: 78,
      o: 79,
      p: 80,
      q: 81,
      r: 82,
      s: 83,
      t: 84,
      u: 85,
      v: 86,
      w: 87,
      x: 88,
      y: 89,
      z: 90,
      leftWinKey: 91,
      rightWinKey: 92,
      selectKey: 93,
      numpad0: 96,
      numpad1: 97,
      numpad2: 98,
      numpad3: 99,
      numpad4: 100,
      numpad5: 101,
      numpad6: 102,
      numpad7: 103,
      numpad8: 104,
      numpad9: 105,
      multiply: 106,
      add: 107,
      subtract: 109,
      decimalPoint: 110,
      divide: 111,
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123,
      semiColon: 186,
      equalSign: 187,
      comma: 188,
      dash: 189,
      period: 190,
      forwardSlash: 191,
      graveAccent: 192,
      openBracket: 219,
      backSlash: 220,
      closeBraket: 221,
      singleQuote: 222
    };

    /**
     * Сбор для отслеживания нажатия клавиш
     * @type {Array}
     * @private
    */


    HSF.prototype._keyListMap = [];

    /**
     * Функция для использования в domDocumentReady
     * @type {String}
     * @private
    */


    HSF.prototype._funcDomReady = '';

    /**
     * Мы ловим и keyDown и keyPress, но когда мы кого-то поймали не должно выполняться дважды.
     * Сюда пишется функция, которую мы выполнили только что на keyDown
     * @type {null|Function}
     * @private
    */


    HSF.prototype._onKeyDowned = null;

    /**
     * Названия месяцов и недель для генератора строк
     * @type {Object}
     * @private
    */


    HSF.prototype._dateNames = {
      monthShort: ['Янв', "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек"],
      monthFull: ['Январь', "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"],
      weekShort: ['Пн', 'Вт', "Ср", "Чт", "Пт", "Сб", "Вс"],
      weekFull: ['Понедельник', 'Вторник', "Среда", "Четверг", "Пятница", "Суббота", "Воскресенье"]
    };

    /**
     * Ширина скролбара в данной системе. Полезно при пиксельхантинге в js
     * @type {Number}
     * @private
    */


    HSF.prototype._scrollBarWidth = -1;

    /**
     * Готово ли дерево док-та
     * @type {Boolean}
     * @private
    */


    HSF.prototype._ready = false;

    /**
     * Путь до лоадера по умолчанию
     * @type {String}
     * @private
    */


    HSF.prototype._defaultLoader = 'img/loader.gif';

    /**
     * Элемент хранящий данные по умолчанию
     * @type {Element}
     * @private
    */


    HSF.prototype._storage = null;

    /**
     * Путь до скрипта
     * @type {String}
     * @private
    */


    HSF.prototype._scriptPath = '';

    /**
     * Кэш правил
     * @type {Object}
     * @private
    */


    HSF.prototype._CSSCache = null;

    /**
     * Системный стайлшит
     * @type {Object}
     * @private
    */


    HSF.prototype._systemStyleSheet = null;

    /**
     * Параметры:
     * - debug: true|false режим отладки
     * - ajaxPoolLength: {numeric} длина пула ajax
     * - counter: (bool) включено ли добавление параметра, защищающего от кешированного ответа
     * - dateNames: (Object) Названия месяцев и недель в календарях
     * @param {Object} options
     * @constructor
    */


    function HSF(options) {
      this.delClassName = __bind(this.delClassName, this);
      this.GMP = __bind(this.GMP, this);
      var ID, ajaxPoolLength, head, k, o, onmessage, s, tail, v, _i, _ref,
        _this = this;
      ajaxPoolLength = 'ajaxPoolLength' in options ? options.ajaxPoolLength : 5;
      for (_i = 0; 0 <= ajaxPoolLength ? _i <= ajaxPoolLength : _i >= ajaxPoolLength; 0 <= ajaxPoolLength ? _i++ : _i--) {
        this._rPool.push({
          ajax: null,
          state: 0,
          func: null,
          err: null
        });
      }
      if ('debug' in options && options.debug === true) {
        this._debug = true;
      }
      if ('counter' in options && !options.counter) {
        this._counterEnabled = false;
      }
      if ('dateNames' in options) {
        _ref = options.dateNames;
        for (k in _ref) {
          if (!__hasProp.call(_ref, k)) continue;
          v = _ref[k];
          this._dateNames[k] = v;
        }
      }
      this._id = this.md5(navigator.userAgent + (new Date()).getTime().toString() + Math.random().toString());
      _HSF[this._id] = this;
      this.onDomReady(function() {
        return document.onkeypress = document.onkeydown = function(e) {
          var list, result, shortcut, _j, _len, _ref1;
          e = e || window.event;
          result = true;
          list = _this._keyListMap[e.keyCode] || [];
          if (list.length) {
            for (_j = 0, _len = list.length; _j < _len; _j++) {
              shortcut = list[_j];
              if (e.ctrlKey === shortcut.ctrl && e.shiftKey === shortcut.shift && e.altKey === shortcut.alt) {
                if (e.type.indexOf('keydown') >= 0 || (_this._onKeyDowned !== shortcut.func)) {
                  result = shortcut.func.call(_this, e) || false;
                  _this._onKeyDowned = shortcut.func;
                } else if (e.type.indexOf('keypress') >= 0 || _this._onKeyDowned === shortcut.func) {
                  _this._onKeyDowned = null;
                  return true;
                }
              }
            }
          }
          if ((!result || ((16 <= (_ref1 = e.keyCode) && _ref1 <= 18))) && "preventDefault" in e) {
            e.preventDefault();
          }
          return result;
        };
      });
      this.onDomReady(function() {
        _this.keyListener('semiColon', function() {
          return _this.printLog();
        }, true);
        if (typeof _this._initIeStorage === 'function') {
          _this._initIeStorage();
        }
      });
      if (!('bind' in Function.prototype)) {
        Function.prototype.bind = function(oThis) {
          var aArgs, fBound, fNOP, fToBind;
          if (typeof this !== "function") {
            throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
          }
          aArgs = Array.prototype.slice.call(arguments, 1);
          fToBind = this;
          fNOP = function() {};
          fBound = function() {
            return fToBind.apply((this instanceof fNOP && oThis ? this : oThis), aArgs.take(arguments));
          };
          fNOP.prototype = this.prototype;
          fBound.prototype = new fNOP();
          return fBound;
        };
      }
      if (!("trim" in String.prototype)) {
        /**
         * Добавляет функцию trim в String там, где этого нет (IE)
         * @return String
        */

        String.prototype.trim = function() {
          return this.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
        };
      }
      s = "test";
      try {
        o = s.replace("t", "d", "g");
      } catch (_error) {}
      if (o !== "desd") {
        String.prototype.replaceOld = String.prototype.replace;
        String.prototype.replace = function(string, newValue, flags) {
          if (!flags || typeof string === 'object') {
            return this.replaceOld(string, newValue);
          } else {
            return this.replaceOld(new RegExp(string.replaceOld(/([\/\,\!\\\^\$\{\}\[\]\(\)\.\*\+\?\|\<\>\-\&])/g, "\\$&"), flags), (typeof newValue === "string" ? newValue.replaceOld(/\$/g, "$$$$") : newValue));
          }
        };
      }
      if (!('forEach' in Array.prototype)) {
        /**
           * forEach executes the provided callback once for each element of
           * the array with an assigned value. It is not invoked for indexes
           * which have been deleted or which have been initialized to undefined.
           *
           * @param {Function} fn Function to execute for each element.
           * @param {Object} [scope] Object to use as this when executing callback.
        */

        Array.prototype.forEach = function(fn, scope) {
          for(var i = 0, len = this.length; i < len; ++i) {
          if (i in this) {
            fn.call(scope, this[i], i, this);
          }
        };
        };
      }
      /**
       * Присоединяет значения массива или списка к текущему массиву
       * Если ничего не переданно, равно как и null, то будет ошибка.
       * Если будет переданн посторонний объект без свойства `length`, то массив изменён не будет,
       * если же у объекта будет `length` то будет прибавденно `length` элементов в конец массива
       *
       * @param {Array|String||NodeList|HTMLCollection} array любой массивоподобный объект
       * @return Array
      */

      Array.prototype.take = function(array) {
        for (var i = 0, j = this.length, l= array.length; i < l; i++, j++) {
        this[j] = array[i];
      };        return this;
      };
      /**
       * Удаляем элемент из массива
       * @param {Number} index индекс элемента
       * @return Array
      */

      Array.prototype.del = function(index) {
        this.splice(index, 1);
        return this;
      };
      if (!('indexOf' in Array.prototype)) {
        /**
         * Получаем элемент в массиве или -1, если его нет. Фикс для старых браузеров
         * @param {*} item элемент массива
         * @param {Number} [startIndex] = 0 начальный индекс
         * @return Number
        */

        Array.prototype.indexOf = function(item, startIndex) {
          var i, l;
          if (startIndex == null) {
            startIndex = 0;
          }
          l = this.length;
          i = startIndex >= 0 ? startIndex | 0 : l - (startIndex | 0);
          while (i < l) {
            if (i in this && this[i] === item) {
              return i;
            }
            i++;
          }
          return -1;
        };
      }
      if (!('setImmediate' in window)) {
        head = {};
        tail = head;
        ID = (Math.random() * 10000000 | 0) + '';
        onmessage = function(e) {
          var func;
          if (e.data !== ID) {
            return;
          }
          head = head.next;
          func = head.func;
          delete head.func;
          return func();
        };
        if (window.addEventListener) {
          window.addEventListener("message", onmessage, false);
        }
        if (window.postMessage && this.browser().name !== 'msie') {
          window.setImmediate = function(func) {
            tail = tail.next = {
              func: func
            };
            window.postMessage(ID, "*");
          };
        } else {
          window.setImmediate = function(func) {
            setTimeout(func, 0);
          };
        }
      }
      this.prepareOnDocumentReady();
    }

    /**
     * Получает строку для обращения из глобальной области видимости для inline функций
     * @return {String}
    */


    HSF.prototype.getThis = function() {
      return "_HSF.get('" + this._id + "')";
    };

    /**
     * Возвращает структуру объекта `o` с глубиной рекурсии `level`.
     *
     * @method toSource
     * @param {Object} o объект, который отображаем
     * @param {Number} [level] глубина рекурсивного перебора, по умолчанию 0
     * @return {String} структура объекта
    */


    HSF.prototype.toSource = function(o, level) {
      var i, isArray, source, space, val, _i, _len;
      if (level == null) {
        level = 0;
      }
      space = arguments[2] || '  ';
      switch (typeof o) {
        case 'object':
          isArray = o instanceof Array;
          if (isArray) {
            source = "[\n";
            for (_i = 0, _len = o.length; _i < _len; _i++) {
              val = o[_i];
              if (typeof val === 'object' && level > 0) {
                source += "" + space + (this.toSource(val, level - 1, space + '  ')) + ",\n";
              } else {
                if (typeof val === "string") {
                  val = '"' + val + '"';
                }
                source += "" + space + val + ",\n";
              }
            }
          } else {
            source = "{\n";
            for (i in o) {
              if (!__hasProp.call(o, i)) continue;
              val = o[i];
              if (typeof val === 'object' && level > 0) {
                source += "" + space + i + ": " + (this.toSource(val, level - 1, space + '  ')) + ",\n";
              } else {
                if (typeof val === "string") {
                  val = '"' + val + '"';
                }
                source += "" + space + i + ": " + val + ",\n";
              }
            }
          }
          if (source.length > 2) {
            source = source.substr(0, source.length - 2) + '\n';
          }
          source += "" + (space.replace('  ', ''));
          if (isArray) {
            source += "]";
          } else {
            source += "}";
          }
          break;
        case 'function':
          source = ('' + o) || 'function(){...}';
          break;
        case 'string':
          source = '"' + o + '"';
          break;
        case 'number':
        case 'boolean':
          source = '' + o;
          break;
        default:
          source = 'undefined';
      }
      return source;
    };

    /**
     * Возвращает количество свойств и методов или длину объекта `o`
     *
     * @method oSize
     * @param {Object|Array|String} o
     * @return {Number} длина объекта
    */


    HSF.prototype.oSize = function(o) {
      var k, s;
      if (o instanceof String || typeof o === 'string') {
        return o.length;
      }
      if (typeof o !== 'object') {
        throw new Error('argument not object');
      }
      if ("keys" in Object) {
        return Object.keys(o).length;
      }
      s = 0;
      for (k in o) {
        if (!__hasProp.call(o, k)) continue;
        s++;
      }
      return s;
    };

    /**
     * Возвращает ключи объекта `o`
     *
     * @method oKeys
     * @param {Object|Array|String} o
     * @return {Array} массив ключей
    */


    HSF.prototype.oKeys = function(o) {
      var k, res;
      if (o instanceof String || typeof o === 'string') {
        return this.oKeys([].take(o));
      }
      if (typeof o !== 'object') {
        throw new Error('argument not object');
      }
      if ("keys" in Object) {
        return Object.keys(o);
      }
      res = [];
      for (k in o) {
        if (!__hasProp.call(o, k)) continue;
        res[res.length] = k;
      }
      return res;
    };

    /**
     * накладывает объект obj2 на объект obj1
     * если нужно создать третий объект (не трогать obj1) из двух надо использовать f.merge(f.merge({},obj1), obj2) <br />
     * (!) Нет защиты от дурака. Если аргументы не объекты, то результат не предсказуем и может быть ошибка.
     *
     * @method merge
     * @param {Object|Array} to модифицируемый объект
     * @param {Object|Array} from модифицирующий объект
     * @return {Object} изменённый to
    */


    HSF.prototype.merge = function(to, from) {
      var e, p;
      for (p in from) {
        if (!__hasProp.call(from, p)) continue;
        try {
          if (typeof from[p] === 'object') {
            to[p] = this.merge(to[p], from[p]);
          } else {
            to[p] = from[p];
          }
        } catch (_error) {
          e = _error;
          to[p] = from[p];
        }
      }
      return to;
    };

    /**
     * Парсит JSON строку в JS объект по RFC 4627 или "родными" средствами
     *
     * @method parseJSON
     * @param   {String} text
     * @return  {Object|Array|Boolean|Number|String|Null}
    */


    HSF.prototype.parseJSON = function(text) {
      if ("JSON" in window && "parse" in JSON) {
        return JSON.parse(text);
      }
      return !(/[^,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]/.test(text.replace(/"(\\.|[^"\\])*"/g, ""))) && eval("(" + text + ")");
    };

    /**
     * Преобразует объект в JSON строку
     *
     * @method varToJSON
     * @param   {Object|Array|Boolean|Number|String|Null} o
     * @return  {String} строка в формате JSON
    */


    HSF.prototype.varToJSON = function(o) {
      var el, i, _a, _i, _len, _ret, _ret2;
      if ("JSON" in window && "stringify" in JSON) {
        return JSON.stringify(o);
      }
      _ret = "";
      _a = "";
      switch (typeof o) {
        case "string":
          return '"' + o + '"';
        case "number":
        case "boolean":
          return o.toString();
        case "object":
          if (o instanceof Array) {
            _ret = "[";
            i = 0;
            for (_i = 0, _len = o.length; _i < _len; _i++) {
              el = o[_i];
              switch (typeof el) {
                case "string":
                  _ret += _a + '"' + el + '"';
                  break;
                case "boolean":
                case "number":
                  _ret += _a + el;
                  break;
                case "object":
                  _ret += _a + varToJSON(el);
              }
              _a = ",";
              i++;
            }
            _ret += "]";
          } else if (o === null) {
            return "null";
          } else {
            _ret = "{";
            for (i in o) {
              if (!__hasProp.call(o, i)) continue;
              if (!o.hasOwnProperty(i)) {
                continue;
              }
              _ret2 = null;
              switch (typeof o[i]) {
                case "string":
                  _ret2 = '"' + o[i] + '"';
                  break;
                case "boolean":
                case "number":
                  _ret2 = o[i];
                  break;
                case "object":
                  _ret2 = varToJSON(o[i]);
              }
              if (_ret2 != null) {
                _ret += _a + '"' + i + '":' + _ret2;
                _a = ",";
              }
            }
            _ret += "}";
          }
      }
      return _ret;
    };

    /**
     * возвращает целое число или 0 (вместо NaN), так же может работать с числами вида 12.3768E+21
     *
     * @method toInt
     * @param {*} value
     * @return {Number} Integer
    */


    HSF.prototype.toInt = function(value) {
      switch (typeof value) {
        case 'boolean':
          return +value;
        case 'string':
          if (/^\d+(\.\d+)?([eE][\+-]?\d+)?$/.test(value)) {
            return eval(value | 0);
          } else {
            return parseInt(value, 10) | 0;
          }
          break;
        default:
          return parseInt(value, 10) | 0;
      }
    };

    /**
     * возвращает число с плавающей точкой или 0 (вместо NaN), так же может работать с числами вида 12.3768E+21
     *
     * @method toFloat
     * @param {*} value
     * @return {Number} Float
    */


    HSF.prototype.toFloat = function(value) {
      var r;
      switch (typeof value) {
        case 'boolean':
          return +value;
        case 'string':
          if (/^\d+(\.\d+)?([eE][\+-]?\d+)?$/.test(value)) {
            return eval(value);
          } else {
            r = parseFloat(value, 10);
          }
          break;
        default:
          r = parseFloat(value, 10);
      }
      if (isNaN(r)) {
        return 0;
      } else {
        return r;
      }
    };

    /**
     * Берёт логарифм от a по основанию b. Если основания не указано, то логарифм натуральный.
     *
     * @method mLog
     * @param {Number} a
     * @param {Number} b = Math.E
     * @return Number
    */


    HSF.prototype.mLog = function(a, b) {
      if (b == null) {
        b = Math.E;
      }
      return 1000 * Math.log(a) / (1000 * Math.log(b));
    };

    /**
     * синоним для document.getElementById
     * @param {String} el
     * @return {Element}
    */


    HSF.prototype.GBI = function(el) {
      return document.getElementById(el);
    };

    /**
     * кросс-браузерная версия для получения элементов по имени класса classname внутри node
     * @param {String} classname
     * @param {Element} [node] = document
     * @return Array|NodeList
    */


    HSF.prototype.GBC = function(classname, node) {
      if (node == null) {
        node = document;
      }
      if ('getElementsByClassName' in node) {
        return node.getElementsByClassName(classname);
      } else {
        return (function(searchClass, node) {
          var classElements, els, elsLen, i, j, pattern;
          classElements = [];
          els = node.getElementsByTagName("*");
          elsLen = els.length;
          pattern = new RegExp("(^|\\s)" + searchClass + "(\\s|$)");
          i = 0;
          j = 0;
          while (i < elsLen) {
            if (pattern.test(els[i].className)) {
              classElements[j] = els[i];
              j++;
            }
            i++;
          }
          return classElements;
        })(classname, node);
      }
    };

    /**
     * синоним для node.getElementsByTagName
     * @param {String} tagName
     * @param {Node} [node] = document
     * @return NodeList
     * @constructor
    */


    HSF.prototype.GBT = function(tagName, node) {
      if (node == null) {
        node = document;
      }
      return node.getElementsByTagName(tagName);
    };

    /**
     * создаём окно по центру с заданной ссылкой и названием.
     * Размеры, а так же различные элементы определяются отдельно
     * @param {String} url
     * @param {String} [title]
     * @param {Number} [width] = 902
     * @param {Number} [height] = 700
     * @param {Object} [option]
     * @return window
    */


    HSF.prototype.openWin = function(url, title, width, height, option, callback) {
      var err, left, link, map, name, top, w, _i, _len, _ref,
        _this = this;
      if (width == null) {
        width = 902;
      }
      if (height == null) {
        height = 700;
      }
      if (option == null) {
        option = {};
      }
      map = {
        resizable: 1,
        scrollbars: 1,
        menubar: 0,
        toolbar: 0,
        status: 1
      };
      try {
        left = ((screen.availWidth || screen.width) / 2) - (width / 2) + (screen.availLeft || 0);
        top = ((screen.availHeight || screen.height) / 2) - (height / 2) + (screen.availTop || 0);
        link = "width=" + (parseInt(width)) + ",height=" + (parseInt(height)) + ",left=" + left + ", top=" + top;
        _ref = ['resizable', 'scrollbars', 'menubar', 'toolbar', 'status'];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          name = _ref[_i];
          link += ("," + name + "=") + (name in option ? (option[name] ? 1 : 0) : map[name]);
        }
        w = window.open(url, title, link);
        w.activated = false;
        w.onfocus = function() {
          if (w.activated) {
            return;
          }
          w.activated = true;
          if (typeof callback === 'function') {
            callback(w);
          } else {
            _this.log('success win open');
          }
          return true;
        };
        w.blocked = !!w.document.getElementById;
        if (w) {
          w.focus();
        }
      } catch (_error) {
        err = _error;
        alert("Ошибка открытия окна - " + title);
      }
      return w || false;
    };

    HSF.prototype.getSelection = function(el) {
      var end, endRange, len, normalizedValue, range, start, textInputRange;
      start = 0;
      end = 0;
      if (typeof el.selectionStart === "number" && typeof el.selectionEnd === "number") {
        start = el.selectionStart;
        end = el.selectionEnd;
      } else {
        range = document.selection.createRange();
        if (range && range.parentElement() === el) {
          len = el.value.length;
          normalizedValue = el.value.replace(/\r\n/g, "\n");
          textInputRange = el.createTextRange();
          textInputRange.moveToBookmark(range.getBookmark());
          endRange = el.createTextRange();
          endRange.collapse(false);
          if (textInputRange.compareEndPoints("StartToEnd", endRange) > -1) {
            start = end = len;
          } else {
            start = -textInputRange.moveStart("character", -len);
            start += normalizedValue.slice(0, start).split("\n").length - 1;
            if (textInputRange.compareEndPoints("EndToEnd", endRange) > -1) {
              end = len;
            } else {
              end = -textInputRange.moveEnd("character", -len);
              end += normalizedValue.slice(0, end).split("\n").length - 1;
            }
          }
        }
      }
      return {
        start: start,
        end: end
      };
    };

    /**
     * получается позиция объекта в документе. Некоторые баги в ИЕ
     * @param {Element} el
     * @param {Element} parent=document
     * @return Object {x:(number),y:(number)}
    */


    HSF.prototype.getPos = function(el, parent) {
      var body, box, clientLeft, clientTop, docElem, left, s, scrollLeft, scrollTop, top;
      if (parent == null) {
        parent = document.body;
      }
      if (!this.hasElement(parent, el)) {
        return false;
      }
      s = {
        x: 0,
        y: 0
      };
      if ('getBoundingClientRect' in el && parent === document.body) {
        box = el.getBoundingClientRect();
        body = document.body;
        docElem = document.documentElement;
        scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
        scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
        clientTop = docElem.clientTop || body.clientTop || 0;
        clientLeft = docElem.clientLeft || body.clientLeft || 0;
        top = box.top + scrollTop - clientTop;
        left = box.left + scrollLeft - clientLeft;
        s.x = Math.round(left);
        s.y = Math.round(top);
      } else if (parent === document.body) {
        if (!el.offsetParent) {
          s.x += el.offsetLeft;
          s.y += el.offsetTop;
        }
        while (el.offsetParent) {
          s.x += el.offsetLeft;
          s.y += el.offsetTop;
          el = el.offsetParent;
        }
      } else {
        while (!this.hasElement(el.offsetParent, parent)) {
          s.x += el.offsetLeft;
          s.y += el.offsetTop;
          el = el.offsetParent;
          if (!el) {
            return s;
          }
        }
        if (el.offsetParent !== parent) {
          s.x += el.offsetLeft - parent.offsetLeft;
          s.y += el.offsetTop - parent.offsetTop;
        } else {
          s.x += el.offsetLeft;
          s.y += el.offsetTop;
        }
      }
      return s;
    };

    /**
     * получается позиция event-a
     * @param {Event} e
     * @return Object {x:(number),y:(number)}
    */


    HSF.prototype.getMousePos = function(e) {
      var posx, posy;
      if (!e) {
        throw new Error('event is empty');
      }
      posx = 0;
      posy = 0;
      if (e.pageX || e.pageY) {
        posx = e.pageX;
        posy = e.pageY;
      } else if (e.clientX || e.clientY) {
        posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
      }
      return {
        x: posx,
        y: posy
      };
    };

    /**
     * alias to getMousePos
     * @param {Event} e
     * @return {Object} {x:(number),y:(number)}
    */


    HSF.prototype.GMP = function(e) {
      return this.getMousePos(e);
    };

    /**
     * получается позиция объекта на экране.
     * @param {Element} el
     * @return {Object} {x:(number),y:(number)}
    */


    HSF.prototype.getScreenPos = function(el) {
      var body, box, clientLeft, clientTop, docElem, s, scrollLeft, scrollTop;
      s = {
        x: 0,
        y: 0
      };
      if ('getBoundingClientRect' in el) {
        box = el.getBoundingClientRect();
        s.x = Math.round(box.left);
        s.y = Math.round(box.top);
      } else {
        box = this.getPos(el);
        body = document.body;
        docElem = document.documentElement;
        scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
        scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
        clientTop = docElem.clientTop || body.clientTop || 0;
        clientLeft = docElem.clientLeft || body.clientLeft || 0;
        s.x = box.x + clientLeft - scrollLeft;
        s.y = box.y + clientTop - scrollTop;
      }
      return s;
    };

    /**
     * получение размеров экрана, возвращается объект с свойствами:
     * w ширина экрана,
     * h высота экрана,
     * s величина прокрутки сверху,
     * sl величина прокрутки слева,
     * sw ширина прокручиваемой области,
     * sh высота документа
     * @return Object
    */


    HSF.prototype.getSize = function() {
      var ret;
      ret = {
        w: 0,
        h: 0,
        s: 0,
        sl: 0,
        sw: 0,
        sh: 0
      };
      if (self.innerHeight) {
        ret.w = window.innerWidth;
        ret.h = window.innerHeight;
        ret.s = window.pageYOffset;
        ret.sl = window.pageXOffset;
      } else if (document.documentElement && document.documentElement.clientHeight) {
        ret.w = document.documentElement.clientWidth;
        ret.h = document.documentElement.clientHeight;
        ret.s = document.documentElement.scrollTop;
        ret.sl = document.documentElement.scrollLeft;
      } else if (document.body) {
        ret.w = document.body.clientWidth;
        ret.h = document.body.clientHeight;
        ret.s = document.body.scrollTop;
        ret.sl = document.body.scrollLeft;
      }
      if (window.innerHeight && window.scrollMaxY) {
        ret.sw = document.body.scrollWidth;
        ret.sh = window.innerHeight + window.scrollMaxY;
      } else if (document.body.scrollHeight > document.body.offsetHeight) {
        ret.sw = document.body.scrollWidth;
        ret.sh = document.body.scrollHeight;
      } else {
        ret.sw = document.body.offsetWidth;
        ret.sh = document.body.offsetHeight;
      }
      return ret;
    };

    /**
     * получаем значение стиля элемента по его DOM-имени
     * @param {Element} el
     * @param {String} styleName
     * @return String
    */


    HSF.prototype.getStyle = function(el, styleName) {
      var ret;
      if (this.browser().name === "msie") {
        if (styleName in el.currentStyle) {
          return el.currentStyle[styleName];
        }
        return '';
      }
      ret = window.getComputedStyle(el, null);
      if (ret[styleName] != null) {
        return ret[styleName];
      }
      return '';
    };

    /**
     * Выставляет стиль, в основном призвын перебирать стили в объекте
     * @param {Element} el
     * @param {String|Object} style
     * @return HSF
    */


    HSF.prototype.setStyle = function(el, style) {
      var k, s;
      switch (typeof style) {
        case 'string':
          el.style.cssText += ";" + style;
          break;
        case 'object':
          for (k in style) {
            s = style[k];
            el.style[k] = s;
          }
          break;
      }
      return this;
    };

    /**
     * Получает индекс элемента у родительского элемента.
     * @param {Element} el
     * @param {Boolean} node = false считать ли среди всех дочерних элементов или только среди тэгов (по умолчанию)
     * @return Number
    */


    HSF.prototype.getIndexElement = function(el, node) {
      if (node == null) {
        node = false;
      }
      if (node === true) {
        return [].take(el.parentNode.childNodes).indexOf(el);
      } else {
        return [].take(el.parentNode.children).indexOf(el);
      }
    };

    /**
     * определяет название браузера и версию
     * @return Object {name:[mozilla|opera|chrome|ie|safari|...], version: (Float)}
    */


    HSF.prototype.browser = function() {
      var chrome, nav, safari, start, v;
      if (this._browser.version !== 0) {
        return this._browser;
      }
      nav = window.navigator;
      chrome = /Chrome\/([\d\.]+)/;
      chrome = nav.userAgent.search(chrome);
      safari = /Safari\/([\d\.]+)/;
      safari = nav.userAgent.search(safari);
      start = 0;
      v = 0;
      if (nav.appName === "Microsoft Internet Explorer") {
        this._browser.name = "msie";
        start = nav.appVersion.indexOf("MSIE") + 5;
        v = nav.appVersion.substring(start, nav.appVersion.indexOf(";", start) - 1);
        this._browser.version = parseFloat(v);
      } else if (chrome !== -1) {
        this._browser.name = "chrome";
        start = nav.appVersion.indexOf("Chrome") + 7;
        v = nav.appVersion.substring(start, nav.appVersion.indexOf(" ", start) - 1);
        this._browser.version = parseFloat(v);
      } else if (nav.appName === "Opera") {
        this._browser.name = "opera";
        start = nav.userAgent.indexOf("Version") + 8;
        v = nav.userAgent.substring(start, nav.userAgent.length);
        this._browser.version = parseFloat(v);
      } else if (safari !== -1) {
        this._browser.name = "safari";
        start = nav.userAgent.indexOf("Version") + 8;
        v = nav.userAgent.substring(start, nav.userAgent.indexOf(" ", start) - 1);
        this._browser.version = parseFloat(v);
      } else if (nav.appName === "Netscape" && nav.appCodeName === "Mozilla" && nav.userAgent.indexOf("Firefox") !== -1) {
        this._browser.name = "mozilla";
        start = nav.userAgent.indexOf("Firefox") + 8;
        v = nav.userAgent.substr(start);
        this._browser.version = parseFloat(v);
      } else {
        this._browser.name = nav.userAgent;
        this._browser.version = parseFloat(nav.appVersion);
      }
      return this._browser;
    };

    /**
     * устанавливаем "память" объекту.
     * пока он будет жив, память можно будет получить
     *
     * @param {Element} el
     * @param {String} prop properties
     * @param {String} val value of properties
     * @param {String} nameSpace = 'HSF' name space, of our params
     * @return Element
    */


    HSF.prototype.setMem = function(el, prop, val, nameSpace) {
      if (nameSpace == null) {
        nameSpace = 'HSF';
      }
      if (nameSpace) {
        if (!(nameSpace in el)) {
          el[nameSpace] = {};
        }
        el[nameSpace][prop] = val;
      } else {
        el[prop] = val;
      }
      return this;
    };

    /**
     * получаем "память" объекта.
     * пока он будет жив, память можно будет получить
     *
     * @param {Element} el
     * @param {String} prop properties
     * @param {String} nameSpace = 'HSF' name space, of our params
     * @return Mixed
    */


    HSF.prototype.getMem = function(el, prop, nameSpace) {
      if (nameSpace == null) {
        nameSpace = 'HSF';
      }
      if (nameSpace in el) {
        if (prop in el[nameSpace]) {
          return el[nameSpace][prop];
        }
      } else if (!nameSpace) {
        if (prop in el) {
          return el[prop];
        }
      }
      return null;
    };

    /**
     * получаем всю память с установленным префиксом
     *
     * @param {Element} el
     * @param {String} nameSpace = 'HSF'
     * @return Object
    */


    HSF.prototype.getMemList = function(el, nameSpace) {
      if (nameSpace == null) {
        nameSpace = 'HSF';
      }
      if (!nameSpace) {
        return {};
      }
      return el[nameSpace];
    };

    /**
     * очищаем всю память с установленным префиксом
     *
     * @param {Element} el
     * @param {String} nameSpace = 'HSF'
     * @return Boolean
    */


    HSF.prototype.clearMem = function(el, nameSpace) {
      if (nameSpace == null) {
        nameSpace = 'HSF';
      }
      if (!nameSpace) {
        return false;
      }
      el[nameSpace] = {};
      return true;
    };

    /**
     * Описываем, что в кнопке должно измениться и какие функции произойти, когда на неё нажимают,
     * прописываем функцию, срабатывающую при отпускании.
     * @param {Element} el
     * @param {Object} props css property
     * @param {Object} opt={} {[down:handler(el)],[up:handler(el)]}
     * @return Boolean
    */


    HSF.prototype.buttonClick = function(el, props, opt) {
      var md, mu,
        _this = this;
      if (opt == null) {
        opt = {};
      }
      md = function() {
        _this.setTempStyle(el, props, 'Click');
        _this.addEvent(el, "mouseout", mu);
        if ('down' in opt) {
          opt.down(el);
        }
        return true;
      };
      mu = function() {
        _this.retTempStyle(el, 'Click');
        _this.removeEvent(el, "mouseout", mu);
        if ('up' in opt) {
          opt.up(el);
        }
        return true;
      };
      this.addEvent(el, "mouseup", mu);
      this.addEvent(el, "mousedown", md);
      if (opt.activate === true) {
        el.onmousedown();
      }
      return this;
    };

    /**
     * Описываем, что в кнопке должно измениться и какие функции произойти, когда на неё наводят,
     * прописываем функцию, срабатывающую при отведении.
     * @param {Element} el
     * @param {Object} props css property
     * @param {Object} opt={} {[down:handler],[up:handler]}
     * @return Boolean
    */


    HSF.prototype.hover = function(el, props, opt) {
      var mout, mover,
        _this = this;
      if (opt == null) {
        opt = {};
      }
      mover = function(e) {
        var src;
        e = e || window.event;
        src = e.toElement || document.body;
        if (e.type !== 'mouseenter' && _this.hasElement(el, src) && _this.getMem(el, 'hover')) {
          return true;
        }
        _this.setTempStyle(el, props, 'Hover');
        if ('over' in opt) {
          opt.over(el);
        }
        _this.setMem(el, 'hover', true);
        return true;
      };
      mout = function(e) {
        var src;
        e = e || window.event;
        src = e.toElement || document.body;
        if (e.type !== 'mouseleave' && _this.hasElement(el, src) && el !== src) {
          return true;
        }
        _this.retTempStyle(el, 'Hover');
        if ('out' in opt) {
          opt.out(el);
        }
        _this.setMem(el, 'hover', false);
        return true;
      };
      if (this.browser().name === "msie") {
        el.attachEvent("onmouseenter", mover);
        el.attachEvent("onmouseleave", mout);
        if (opt.activate === true) {
          mover({
            toElement: el
          });
        }
      } else {
        if ('onmouseenter' in el) {
          el.addEventListener("mouseenter", mover, false);
          el.addEventListener("mouseleave", mout, false);
          if (opt.activate === true) {
            mover({
              toElement: el
            });
          }
        } else {
          el.addEventListener("mouseover", mover, false);
          el.addEventListener("mouseout", mout, false);
          if (opt.activate === true) {
            mover({
              toElement: el
            });
          }
        }
      }
      return this;
    };

    /**
     * Устанавливает временный стиль, записывая старый стиль в память объекта
     * @param {Element} el
     * @param {Object} props css property
     * @param {String} state имя блока стилей
     * @return HSF
    */


    HSF.prototype.setTempStyle = function(el, props, state) {
      var k, oldState, touch, v;
      touch = this.getMem(el, 'touch');
      if (!touch) {
        oldState = 'originStyle';
        touch = ["oldStyle" + state];
      } else {
        oldState = touch[touch.length - 1];
        touch.push("oldStyle" + state);
      }
      for (k in props) {
        if (!__hasProp.call(props, k)) continue;
        v = props[k];
        if (k in el.style) {
          this.setMem(el, k, el.style[k], oldState).setMem(el, k, v, "oldStyle" + state);
          el.style[k] = v;
        }
      }
      return this.setMem(el, 'touch', touch);
    };

    /**
     * Восстанавливает указанные в props ывойства из state блока
     * @param {Element} el
     * @param {Object} props css property
     * @param {String} state имя блока стилей
     * @return HSF
    */


    HSF.prototype.retTempStyle = function(el, state) {
      var index, k, oldState, oldStyle, props, touch, v, _ref;
      props = this.getMemList(el, "oldStyle" + state);
      if (!props) {
        return this;
      }
      touch = this.getMem(el, 'touch');
      if (!touch) {
        return this;
      }
      index = touch.indexOf("oldStyle" + state);
      if (index < 0) {
        f.log('Error: retTempStyle: index tempStyle is -1');
        return this;
      }
      oldState = index > 0 ? touch[index - 1] : 'originStyle';
      oldStyle = this.getMemList(el, oldState);
      for (k in props) {
        if (k in oldStyle) {
          el.style[k] = oldStyle[k];
        } else {
          oldStyle[k] = props[k];
        }
      }
      touch.del(index);
      if (index !== touch.length) {
        while (index < touch.length) {
          _ref = this.getMemList(el, touch[index]);
          for (k in _ref) {
            v = _ref[k];
            el.style[k] = v;
          }
          index++;
        }
      }
      if (touch.length === 0) {
        touch = null;
      }
      return this.setMem(el, 'touch', touch);
    };

    /**
     * Добавление функции для действия
     * @param {Element} elem
     * @param {String} evType
     * @param {Function} fn имя блока стилей
     * @return Boolean|Function функция для удаления эвента или false
    */


    HSF.prototype.addEvent = function(elem, evType, fn) {
      var bVersion, collectByType, eventElem, func, hashChangeCorrect, oldHash, oldHref, onEvType,
        _this = this;
      evType = evType.replace(/^on/, '');
      if ('addEventListener' in elem) {
        elem.addEventListener(evType, fn, false);
      } else {
        onEvType = "on" + evType;
        if (!(onEvType in elem) && evType !== 'hashchange') {
          return false;
        }
        if (evType === 'hashchange' && 'location' in elem) {
          hashChangeCorrect = false;
          bVersion = this._browser.version;
          switch (this._browser.name) {
            case 'msie':
              if (document.documentMode < 8) {
                hashChangeCorrect = true;
              }
              break;
            case 'mozilla':
              if (bVersion < 3.6) {
                hashChangeCorrect = true;
              }
              break;
            case 'chrome':
            case 'safari':
              if (bVersion < 5) {
                hashChangeCorrect = true;
              }
              break;
            case 'opera':
              if (bVersion < 10.6) {
                hashChangeCorrect = true;
              }
              break;
            default:
              hashChangeCorrect = true;
          }
          if (hashChangeCorrect) {
            elem.onhashchange = null;
            oldHash = elem.location.hash;
            oldHref = elem.location.href;
            window.setInterval(function() {
              try {
                if (elem.location.hash !== oldHash) {
                  oldHash = elem.location.hash;
                  oldHref = elem.location.href;
                  if (typeof elem.onhashchange === 'function') {
                    return elem.onhashchange.call(elem, {
                      target: elem,
                      timestamp: new Date().getTime(),
                      oldURL: oldHref,
                      newURL: elem.location.hash
                    });
                  }
                }
              } catch (_error) {}
            }, 42);
          }
        }
        func = function(e) {
          var _i, _len, _ref;
          e = e || window.event;
          e.target = e.target || e.srcElement;
          _ref = _this.getMem(elem, evType, 'eventsListener');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            func = _ref[_i];
            func.call(elem, e);
          }
          return true;
        };
        if (onEvType in elem && !elem[onEvType]) {
          this.setMem(elem, evType, [fn], 'eventsListener');
          elem[onEvType] = func;
        } else {
          if (!this.getMem(elem, evType, 'eventsListener')) {
            eventElem = elem[onEvType];
            this.setMem(elem, evType, [eventElem], 'eventsListener');
            elem[onEvType] = func;
          }
          this.getMem(elem, evType, 'eventsListener').push(fn);
        }
      }
      if (this._debug === true) {
        collectByType = this.getMem(elem, evType, 'eventListenerCollect');
        if (collectByType === null) {
          this.setMem(elem, evType, [
            {
              fn: fn,
              enable: true
            }
          ], 'eventListenerCollect');
        } else {
          collectByType.push({
            fn: fn,
            enable: true
          });
        }
      }
      return function() {
        return _this.removeEvent(elem, evType, fn);
      };
    };

    /**
     * Удаление функции из слушателей
     * @param {Element} elem
     * @param {String} evType
     * @param {Function} fn имя блока стилей
     * @return Boolean
    */


    HSF.prototype.removeEvent = function(elem, evType, fn) {
      var collectByType, fns, func, nfns, val, _i, _j, _len, _len1;
      evType = evType.replace(/^on/, '');
      if (elem.addEventListener) {
        elem.removeEventListener(evType, fn, false);
      } else {
        fns = this.getMem(elem, evType, 'eventsListener');
        nfns = [];
        for (_i = 0, _len = fns.length; _i < _len; _i++) {
          val = fns[_i];
          if (val !== fn) {
            nfns.push(val);
          }
        }
        this.setMem(elem, evType, nfns, 'eventsListener');
      }
      if (this._debug === true) {
        collectByType = this.getMem(elem, evType, 'eventListenerCollect');
        for (_j = 0, _len1 = collectByType.length; _j < _len1; _j++) {
          func = collectByType[_j];
          if (func.fn === fn) {
            func.enable = false;
          }
        }
      }
      return true;
    };

    /**
     * AJAX запрос
     * может принять необходимые аргументы, а может и объект, где:
     *   url: String собственно адрес
     *   scs: function(data) вызывается при успешном выполнении
     *   err: function(data) вызывается при неудачном выполнении
     *   data: String данные для POST метода
     *   method: String
     *   header: Object вида {header1Name: header1Value[, headerXName: headerXValue]...}
     * @param {String|Object} url к какому URL
     * @param {Function} [func]
     * @param {String} [data|err]
     * @param {String} [data]
     * @return String|XMLHttpRequest|ActiveXObject
    */


    HSF.prototype.load = function(url, func, err, data) {
      var active, d, e, errorTex, header, i, label, method, value,
        _this = this;
      if (typeof url === 'object') {
        if ('scs' in url) {
          func = url.scs;
        }
        if ('success' in url) {
          func = erl.success;
        }
        if ('err' in url) {
          err = url.err;
        }
        if ('error' in url) {
          err = url.error;
        }
        if ('data' in url) {
          data = url.data;
        }
        if ('method' in url) {
          method = url.method;
        }
        if ('header' in url) {
          header = url.header;
        }
        url = url.url;
      } else if (typeof err === 'object') {
        data = err;
      }
      active = -1;
      i = 0;
      errorTex = '';
      while (i < this._rPool.length) {
        if (this._rPool[i]["state"] === 0) {
          active = i;
          this._rPool[i]["state"] = 1;
          break;
        }
        i++;
      }
      if (active < 0) {
        active = this._rPool.length;
        this._rPool[active] = {
          ajax: null,
          state: 1,
          func: null,
          err: null
        };
      }
      if (!this._rPool[active].ajax) {
        this._rPool[active].ajax = null;
        if (this._debug) {
          if ('XMLHttpRequest' in window) {
            try {
              this._rPool[active].ajax = new XMLHttpRequest();
            } catch (_error) {
              e = _error;
              errorTex += "Cant't create XMLHttpRequest object, but XMLHttpRequest exists. Error: " + e.message;
              this.log(e.message);
            }
          } else if (window.ActiveXObject) {
            try {
              this._rPool[active].ajax = new ActiveXObject("Msxml2.XMLHTTP");
            } catch (_error) {
              e = _error;
              try {
                this._rPool[active].ajax = new ActiveXObject("Microsoft.XMLHTTP");
              } catch (_error) {
                e = _error;
                errorTex += "Cant't create ActiveXObject object, but ActiveXObject exists. Error: " + e.message;
                this.log(e.message);
              }
            }
          }
        } else {
          this._rPool[active].ajax = 'XMLHttpRequest' in window ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");
        }
        this._rPool[active].ajax.onreadystatechange = function() {
          var xhr;
          xhr = null;
          var xhr = this;
          if (xhr.readyState === 4) {
            active = xhr["active"];
            if (xhr.status === 200 || (xhr.status === 0 && xhr.responseText.length > 0)) {
              _this._rPool[active].func(xhr.responseText, xhr.getAllResponseHeaders());
            } else {
              _this._rPool[active].err(xhr.statusText);
            }
            _this._rPool[active].state = 0;
          }
          return true;
        };
      } else if (errorTex !== '') {
        this._rPool[active]["state"] = 0;
        return errorTex;
      }
      if (this._rPool[active].ajax) {
        this._rPool[active].func = func;
        this._rPool[active].err = err ? err : function() {
          return true;
        };
        this._rPool[active].ajax["active"] = active;
        this._rPool[active].state = 1;
        if (data == null) {
          d = this._counterEnabled ? (url.indexOf("?") > 0 ? '&' : '?') + 'cOuNtEr=' + this._counter++ : '';
          this._rPool[active].ajax.open(method || "GET", url + d, true);
          if (header) {
            for (label in header) {
              value = header[label];
              this._rPool[active].ajax.setRequestHeader(label, value);
            }
          }
          this._rPool[active].ajax.send(null);
        } else {
          this._rPool[active].ajax.open(method || "POST", url, true);
          this._rPool[active].ajax.setRequestHeader("Content-length", data.length);
          this._rPool[active].ajax.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
          if (header) {
            for (label in header) {
              value = header[label];
              this._rPool[active].ajax.setRequestHeader(label, value);
            }
          }
          this._rPool[active].ajax.send(data);
        }
        return this._rPool[active].ajax;
      }
      return errorTex || "err";
    };

    /**
     * Создаём бабл в центре экрана с шириной w и высотой h, с содержимым html
     * В опции можно передать:
     *   close: function наступает при закрытии окна
     *   resize: Boolean определяет, подгонять ли высоту по содержимому, если не умещается внутри
     *
     * @param {string} html
     * @param {Number} [w] = 300
     * @param {Number} [h] = 200
     * @param {Object} [options] см выше
     * @return Boolean|HSF
    */


    HSF.prototype.createBubble = function(html, w, h, options) {
      var bc, bg, bgh, bodyChildrens, bubble, bubbleContainer, closeBtn, height, hght, i, img, l, t, top, ws, zIndex, zi,
        _this = this;
      if (w == null) {
        w = 300;
      }
      if (h == null) {
        h = 200;
      }
      if (options == null) {
        options = {};
      }
      if (!html) {
        return false;
      }
      this.closeBubble();
      bubble = this.GBI("bubbleItem");
      bubbleContainer = null;
      ws = this.getSize();
      if (!bubble) {
        bodyChildrens = document.body.children;
        zIndex = 10;
        i = 0;
        this.setCSS('.bubbleItem', {
          'background-color': 'white',
          'font-family': 'Verdana, "Geneva CY", "DejaVu Sans", sans-serif',
          'font-size': '80%'
        }).setCSS('.bubbleItem .closeBtn', {
          cursor: 'pointer',
          float: 'right',
          width: '12px'
        }).setCSS('.bubbleItem .bubbleContainer', {
          'margin': '19px 10px 0',
          'text-align': 'left'
        }).setCSS('.bubbleItem .alertBubble', {
          overflow: 'hidden'
        }).setCSS('.bubbleItem .alertBubble > button[onclick]', {
          'float': 'right',
          'margin-right': '10px',
          'margin-top': '10px'
        });
        bg = this.createElement('#bubbleBG', {
          style: {
            display: 'block',
            position: 'fixed',
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            zIndex: zIndex,
            backgroundColor: '#ccc',
            opacity: '0.5'
          }
        }, document.body);
        while (i < bodyChildrens.length) {
          bc = bodyChildrens[i];
          if (bc != null) {
            zi = this.toInt(this.getStyle(bc, "zIndex"));
          } else {
            zi = 0;
          }
          if (zi > zIndex) {
            zIndex = zi + 1;
          }
          i++;
        }
        bg.style.zIndex = zIndex;
        bubble = this.createElement("#bubbleItem.bubbleItem", {
          style: {
            position: 'absolute'
          },
          close: function() {
            var func;
            bg.style.display = "none";
            bubble.style.display = "none";
            _this.clearElement(bubbleContainer);
            func = _this.getMem(bubble, "func");
            if (func !== null) {
              func();
              return _this.setMem(bubble, "func", null);
            }
          }
        }, document.body);
        bubble.style.zIndex = zIndex + 1;
        closeBtn = this.createElement(".closeBtn", {
          innerHTML: 'X',
          onclick: bubble.close
        }, bubble);
        bg.onclick = bubble.close;
        bubbleContainer = this.createElement(".bubbleContainer", {}, bubble);
        this.setOnResize(bg, function() {
          var l, t;
          ws = _this.getSize();
          l = (ws.w - parseInt(bubble.style.width)) / 2;
          t = (ws.h - parseInt(bubble.style.height)) / 2 + _this.getMem(bubble, 's');
          if (l < 0) {
            l = 0;
          } else {
            l += "px";
          }
          if (t < 0) {
            t = 0;
          } else {
            t += "px";
          }
          bubble.style.left = l;
          return bubble.style.top = t;
        });
        this.keyListener('esc', function() {
          return _this.closeBubble();
        });
      }
      bubble.style.width = w + "px";
      bubble.style.height = h + "px";
      l = (ws.w - w) / 2;
      t = (ws.h - h) / 2;
      if (l < 0) {
        l = 0;
      } else {
        l += "px";
      }
      if (t < 0) {
        t = 0;
      } else {
        t += "px";
      }
      bubble.style.left = l;
      bubble.style.top = t;
      if (bubbleContainer === null) {
        bubbleContainer = bubble.getElementsByTagName("div")[1];
      }
      bubbleContainer.style.overflowY = '';
      if (typeof html === "string") {
        bubbleContainer.innerHTML = html;
      } else if (typeof html === "object" && "nodeType" in html) {
        this.clearElement(bubbleContainer);
        bubbleContainer.appendChild(html);
      } else {
        return false;
      }
      bubble.style.display = "block";
      bg = this.GBI("bubbleBG");
      bg.style.display = "block";
      if ("close" in options) {
        this.setMem(bubble, "func", options.close);
      } else {
        this.setMem(bubble, "func", null);
      }
      if ('loader' in options && options.loader) {
        this.setTempStyle(f.GBC('closeBtn', bubble)[0], {
          display: 'none'
        }, 'loader');
        img = f.GBT('img', bubble)[0];
        bubble.style.left = ws.w / 2 - img.offsetWidth + 'px';
        bubble.style.top = ws.h / 2 - img.offsetHeight + 'px';
        f.GBI('bubbleBG').onclick = null;
        f.setMem(bubble, 'flagLoader', true);
      } else if (f.getMem(bubble, 'flagLoader')) {
        this.retTempStyle(f.GBC('closeBtn', bubble)[0], 'loader');
        f.GBI('bubbleBG').onclick = bubble.close;
        f.setMem(bubble, 'flagLoader', false);
      }
      if ('resize' in options && options.resize) {
        bgh = bg.offsetHeight;
        if (bubbleContainer.children[0].offsetHeight + bubble.children[0].offsetHeight > bubble.offsetHeight) {
          if (bubbleContainer.children[0].offsetHeight < bgh - 20) {
            hght = bubbleContainer.children[0].offsetHeight + bubble.children[0].offsetHeight + 20;
            h = hght > h ? hght : h;
            bubble.style.top = "" + ((ws.h - h) / 2) + "px";
            bubble.style.height = h + 'px';
          } else {
            bubble.style.height = "" + (bgh - 20) + "px";
            bubble.style.top = '10px';
            bubbleContainer.style.overflowY = 'scroll';
          }
        }
      }
      top = parseInt(bubble.style.top);
      height = parseInt(bubble.style.height);
      this.setMem(bubble, 's', ws.s);
      if (ws.s > 0) {
        if (ws.sh < ws.s + top + height) {
          if (ws.sh > top + height) {
            bubble.style.top = (top + (ws.sh - height)) + 'px';
          } else {

          }
        } else {
          if (ws.h < height) {
            bubble.style.top = ws.s + 'px';
          } else {
            bubble.style.top = top + ws.s + 'px';
          }
        }
      }
      return this;
    };

    /**
     * закрывает бабл
     * @return Boolean|Element
    */


    HSF.prototype.closeBubble = function() {
      if (this.GBI("bubbleItem")) {
        this.GBI("bubbleItem").close();
      }
      return this;
    };

    /**
     * Возвращает бабл, если он есть или null
     * @return Element|NULL
    */


    HSF.prototype.getBubble = function() {
      return this.GBI("bubbleItem") || null;
    };

    /**
     * Создаёт бабл, который появляется при загрузке.
     * TODO: сделать так, чтобы в качестве img можно было передавать Element
     * @param {string} img
     * @return Boolean|HSF
    */


    HSF.prototype.createLoaderBubble = function(img) {
      if (img == null) {
        img = this._defaultLoader;
      }
      return this.createBubble("<div style='text-align:center;margin-top:50px;'><img src='" + img + "' alt='ajax-loader'/></div>", 0, 0, {
        loader: true
      });
    };

    /**
     * аналог alert, но не блокирует все скрипты.
     * @param {String} text путь к картинке
     * @return Boolean|HSF
    */


    HSF.prototype.createAlertBubble = function(text, option) {
      if (option == null) {
        option = {};
      }
      option.resize = true;
      return this.createBubble("<div class=\"alertBubble\"><span>" + text + "</span><button onclick=\"" + (this.getThis()) + ".closeBubble();\">Ok</button></div>", 400, 60, option);
    };

    /*
    # Calculate the md5 hash of a string
    #
    # +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
    # + namespaced by: Michael White (http://crestidg.com)
    */


    /**
     * md5 сумму подсчитывает по строке.
     * @param {String} str
     * @return String
    */


    HSF.prototype.md5 = function(str) {
      var AA, AddUnsigned, BB, CC, ConvertToWordArray, DD, F, FF, G, GG, H, HH, I, II, RotateLeft, S11, S12, S13, S14, S21, S22, S23, S24, S31, S32, S33, S34, S41, S42, S43, S44, WordToHex, a, b, c, d, k, temp, x;
      RotateLeft = function(lValue, iShiftBits) {
        return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
      };
      AddUnsigned = function(lX, lY) {
        var lResult, lX4, lX8, lY4, lY8;
        lX8 = lX & 0x80000000;
        lY8 = lY & 0x80000000;
        lX4 = lX & 0x40000000;
        lY4 = lY & 0x40000000;
        lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
        if (lX4 & lY4) {
          return lResult ^ 0x80000000 ^ lX8 ^ lY8;
        }
        if (lX4 | lY4) {
          if (lResult & 0x40000000) {
            return lResult ^ 0xC0000000 ^ lX8 ^ lY8;
          } else {
            return lResult ^ 0x40000000 ^ lX8 ^ lY8;
          }
        } else {
          return lResult ^ lX8 ^ lY8;
        }
      };
      F = function(x, y, z) {
        return (x & y) | ((~x) & z);
      };
      G = function(x, y, z) {
        return (x & z) | (y & (~z));
      };
      H = function(x, y, z) {
        return x ^ y ^ z;
      };
      I = function(x, y, z) {
        return y ^ (x | (~z));
      };
      FF = function(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
      };
      GG = function(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
      };
      HH = function(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
      };
      II = function(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
      };
      ConvertToWordArray = function(str) {
        var lByteCount, lBytePosition, lMessageLength, lNumberOfWords, lNumberOfWords_temp1, lNumberOfWords_temp2, lWordArray, lWordCount;
        lMessageLength = str.length;
        lNumberOfWords_temp1 = lMessageLength + 8;
        lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
        lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
        lWordArray = new Array(lNumberOfWords - 1);
        lBytePosition = 0;
        lByteCount = 0;
        while (lByteCount < lMessageLength) {
          lWordCount = (lByteCount - (lByteCount % 4)) / 4;
          lBytePosition = (lByteCount % 4) * 8;
          lWordArray[lWordCount] = lWordArray[lWordCount] | (str.charCodeAt(lByteCount) << lBytePosition);
          lByteCount++;
        }
        lWordCount = (lByteCount - (lByteCount % 4)) / 4;
        lBytePosition = (lByteCount % 4) * 8;
        lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
        lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
        lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
        return lWordArray;
      };
      WordToHex = function(lValue) {
        var WordToHexValue, WordToHexValue_temp, lByte, lCount;
        WordToHexValue = "";
        WordToHexValue_temp = "";
        lCount = 0;
        while (lCount <= 3) {
          lByte = (lValue >>> (lCount * 8)) & 255;
          WordToHexValue_temp = "0" + lByte.toString(16);
          WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
          lCount++;
        }
        return WordToHexValue;
      };
      S11 = 7;
      S12 = 12;
      S13 = 17;
      S14 = 22;
      S21 = 5;
      S22 = 9;
      S23 = 14;
      S24 = 20;
      S31 = 4;
      S32 = 11;
      S33 = 16;
      S34 = 23;
      S41 = 6;
      S42 = 10;
      S43 = 15;
      S44 = 21;
      str = this.utf8_encode(str);
      x = ConvertToWordArray(str);
      a = 0x67452301;
      b = 0xEFCDAB89;
      c = 0x98BADCFE;
      d = 0x10325476;
      k = 0;
      while (k < x.length) {
        AA = a;
        BB = b;
        CC = c;
        DD = d;
        a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
        d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
        c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
        b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
        a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
        d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
        c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
        b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
        a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
        d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
        c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
        b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
        a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
        d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
        c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
        b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
        a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
        d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
        c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
        b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
        a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
        d = GG(d, a, b, c, x[k + 10], S22, 0x2441453);
        c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
        b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
        a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
        d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
        c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
        b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
        a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
        d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
        c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
        b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
        a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
        d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
        c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
        b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
        a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
        d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
        c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
        b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
        a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
        d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
        c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
        b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
        a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
        d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
        c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
        b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
        a = II(a, b, c, d, x[k + 0], S41, 0xF4292244);
        d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
        c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
        b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
        a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
        d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
        c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
        b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
        a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
        d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
        c = II(c, d, a, b, x[k + 6], S43, 0xA3014314);
        b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
        a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
        d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
        c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
        b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
        a = AddUnsigned(a, AA);
        b = AddUnsigned(b, BB);
        c = AddUnsigned(c, CC);
        d = AddUnsigned(d, DD);
        k += 16;
      }
      temp = WordToHex(a) + WordToHex(b) + WordToHex(c) + WordToHex(d);
      return temp.toLowerCase();
    };

    /**
     * Функция кодирует в utf8 нужна для md5
     * @param {String} str_data
     * @return String
    */


    HSF.prototype.utf8_encode = function(str_data) {
      var c, n, utftext;
      str_data = str_data.replace(/\r\n/g, "\n");
      utftext = "";
      n = 0;
      while (n < str_data.length) {
        c = str_data.charCodeAt(n);
        if (c < 128) {
          utftext += String.fromCharCode(c);
        } else if ((c > 127) && (c < 2048)) {
          utftext += String.fromCharCode((c >> 6) | 192);
          utftext += String.fromCharCode((c & 63) | 128);
        } else {
          utftext += String.fromCharCode((c >> 12) | 224);
          utftext += String.fromCharCode(((c >> 6) & 63) | 128);
          utftext += String.fromCharCode((c & 63) | 128);
        }
        n++;
      }
      return utftext;
    };

    /**
     * Создаёт элемент по шаблону tag с свойствами из option и прикрепляет в parent
     * последовательность важна! Сначала тэг, потом ID и уже потом имена классов
     * @param {String} tag [tagName][#tagId][.tagClass1][.tagClass2][...]
     * @param {Object} [option] ограничение на вложенные свойство. Не распространяется на style
     * @param {Element} [parent]
     * @return Element
    */


    HSF.prototype.createElement = function(tag, option, parent) {
      var el, key, regRes, tagName, val, _ref;
      if (option == null) {
        option = {};
      }
      if (/^\w+$/.test(tag)) {
        el = document.createElement(tag);
      } else {
        regRes = tag.match(/^(\w+)?(#(.*?))?(\.(.*))?$/);
        tagName = regRes[1] || 'div';
        el = document.createElement(tagName);
        if (typeof regRes[3] === 'string') {
          el.id = regRes[3];
        }
        if (typeof regRes[5] === 'string') {
          el.className = regRes[5].replace(/[\.\s]/, ' ');
        }
      }
      if ('style' in option) {
        _ref = option.style;
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          val = _ref[key];
          el.style[key] = val;
        }
        delete option.style;
      }
      for (key in option) {
        if (!__hasProp.call(option, key)) continue;
        val = option[key];
        el[key] = val;
      }
      if (parent) {
        parent.appendChild(el);
      }
      return el;
    };

    /**
     * прикрепляет к parent ребёнка из дочерний элемент el
     * Если el строка, то это равносильно parent.innerHTML += el, но не ломается DOM-модель
     * @param {Element} parent
     * @param {Element|String} el
     * @return Array массив элементов
    */


    HSF.prototype.appendChild = function(parent, el) {
      var div, elems, i, l;
      if (typeof el === 'string') {
        div = document.createElement('div');
        div.innerHTML = el;
        elems = [];
        i = 0;
        l = div.childNodes.length;
        el = [];
        while (i < l) {
          el[el.length] = div.childNodes[0];
          parent.appendChild(div.childNodes[0]);
          i++;
        }
        div = null;
        return el;
      } else if (typeof el === 'object' && 'nodeType' in el) {
        parent.appendChild(el);
      } else {
        throw new Error('el must be string or element');
      }
      return [el];
    };

    /**
    * удаляет элемент el из общего DOM
    * @param {Element} el
    */


    HSF.prototype.removeElement = function(el) {
      el.parentNode.removeChild(el);
      return this;
    };

    /**
     * заменяет элемент el на newEl
     * @param {Element} el
     * @param {Element} newEl
    */


    HSF.prototype.replaceElement = function(el, newEl) {
      el.parentNode.replaceChild(newEl, el);
      return this;
    };

    /**
     * Очищает элемент. Как оказалось innerHTML = '' довольно затратная операция
     * @param {Element} el
    */


    HSF.prototype.clearElement = function(el) {
      var childs, i;
      childs = el.childNodes;
      i = childs.length;
      while (i--) {
        el.removeChild(childs[i]);
      }
      return this;
    };

    /**
     * Устанавливает стиль по имени вне зависимости от префиксов, если стиль вообще существует.
     * имя стилей следует преобразовывать в CamelCase c маленькой буквы
     * @param   {Element}           el
     * @param   {String}            name имя в стиле borderRadius
     * @param   {String|Number}     value
     * @return  Boolean
    */


    HSF.prototype.setUniversalStyle = function(el, name, value) {
      var index, style, styleName, webkitName, _i, _len, _ref, _ref1;
      name = name.toLowerCase();
      if (!(name in this._setUniversalStyleCascade)) {
        this._setUniversalStyleCascade[name] = [];
        for (style in el.style) {
          if (typeof style === 'string') {
            index = style.toLowerCase().indexOf(name);
            if (index >= 0 && index + name.length === style.length && (_ref = style.substr(0, index).toLowerCase(), __indexOf.call(this._stylePrefixes, _ref) >= 0)) {
              this._setUniversalStyleCascade[name].push(style);
            }
          }
        }
        if (this.browser().name === 'safari') {
          if (name in el.style) {
            this._setUniversalStyleCascade[name].push(name);
          }
          webkitName = "webkit" + name.substr(0, 1).toUpperCase() + name.substr(1);
          if (webkitName in el.style) {
            this._setUniversalStyleCascade[name].push(webkitName);
          }
        }
      }
      _ref1 = this._setUniversalStyleCascade[name];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        styleName = _ref1[_i];
        try {
          el.style[styleName] = value;
        } catch (_error) {}
      }
      return true;
    };

    /**
     * Устанавливает, есть ли в элементе el потомок child
     * @param   {Element}   el
     * @param   {Element}   child
     * @return  Boolean
    */


    HSF.prototype.hasElement = function(el, child, childOnly) {
      var e, html, parent;
      if (childOnly == null) {
        childOnly = false;
      }
      if ('contains' in el) {
        if (childOnly) {
          return el.contains(child);
        } else {
          return el === child || el.contains(child);
        }
      }
      try {
        if (el === child && !childOnly) {
          return true;
        }
        parent = child.parentNode;
        if (!parent || !parent.parentNode) {
          return false;
        }
        html = document.getElementsByTagName('html')[0];
        while (parent !== el) {
          if ((parent == null) || parent === html) {
            return false;
          }
          parent = parent.parentNode;
        }
        return true;
      } catch (_error) {
        e = _error;
        this.log('hasElement' + e.message, 'warn');
        return false;
      }
    };

    /**
     * Устанавливает отслеживание изменение размеров элементов в документе.
     * Работает через единый таймер или через onresize
     * Если объект активируется повторно и нет funcName, то использыется прежняяфункция
     * @param {Element} el элемент
     * @param {Function} [funcName] callback фенкция, вызываемая при изменении размеров
     * @return Number|Boolean
    */


    HSF.prototype.setOnResize = function(el, funcName) {
      var col, pos,
        _this = this;
      pos = this.getMem(el, "resizePos");
      if (pos !== null) {
        col = this._onResizeCollection[pos];
        if (funcName) {
          col.func = funcName;
        }
        if (col.type === 1) {
          col.action = this.addEvent(el, 'resize', col.func);
        } else {
          this._onResizeArray[this._onResizeArray.length] = pos;
        }
        return pos;
      }
      pos = this._onResizeCollection.length;
      if ("onresize" in el) {
        this._onResizeCollection[pos] = {
          el: el,
          func: funcName,
          type: 1,
          action: this.addEvent(el, 'resize', funcName)
        };
        return pos;
      }
      if (typeof el !== "object") {
        return -1;
      }
      if (!("nodeType" in el)) {
        return -1;
      }
      this._onResizeCollection[pos] = {
        el: el,
        func: funcName,
        type: 0,
        action: null
      };
      this._onResizeArray[this._onResizeArray.length] = pos;
      this.setMem(el, "ow", el.offsetWidth);
      this.setMem(el, "oh", el.offsetHeight);
      this.setMem(el, "resizePos", pos);
      window.setInterval(function() {
        return _this.resizeObjects();
      }, 42);
      return pos;
    };

    /**
     * Таймер отслеживает изменения по номерам позиции.
     * @private
    */


    HSF.prototype.resizeObjects = function() {
      var el, oh, ow, position, _i, _len, _ref;
      _ref = this._onResizeArray;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        position = _ref[_i];
        el = this._onResizeCollection[position];
        ow = this.getMem(el.el, "ow");
        oh = this.getMem(el.el, "oh");
        if (ow !== el.el.offsetWidth || oh !== el.el.offsetHeight) {
          this.setMem(el.el, "ow", el.el.offsetWidth);
          this.setMem(el.el, "oh", el.el.offsetHeight);
          el.func.call(el.el, position);
        }
      }
      return true;
    };

    /**
     * Выключает таймер по позиции, которая возвращалась в setOnResize
     * @param {Number} pos
     * @return Object
    */


    HSF.prototype.offOnResize = function(pos) {
      var col, na, position, _i, _len, _ref;
      col = this._onResizeCollection[pos];
      if (col.type === 1) {
        col.action();
      } else {
        if (__indexOf.call(this._onResizeArray, pos) < 0) {
          return col;
        }
        na = [];
        _ref = this._onResizeArray;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          position = _ref[_i];
          if (pos !== position) {
            na[na.length] = position;
          }
        }
        this._onResizeArray = na;
      }
      return col;
    };

    /**
     * Добавляет к элементу название класса
     * @param {Element} el
     * @param {String} className
     * @return Element
    */


    HSF.prototype.addClassName = function(el, className) {
      if (!this.hasClassName(el, className)) {
        el.className += " " + (className.trim());
      }
      return this;
    };

    /**
     * Определяет, имеет ли документ определённый класс
     * @param {Element} el
     * @param {String} className
     * @return Boolean
    */


    HSF.prototype.hasClassName = function(el, className) {
      return !((" " + el.className + " ").indexOf(" " + (className.trim()) + " ") < 0);
    };

    /**
     * Удаляет у элемента название класса
     * @param {Element} el
     * @param {String}  className
     * @return Element
    */


    HSF.prototype.removeClassName = function(el, className) {
      if (this.hasClassName(el, className)) {
        el.className = (" " + el.className + " ").replace(" " + (className.trim()) + " ", " ").trim();
      }
      return this;
    };

    /**
     * синоним для removeClassName
     * @param   {Element} el
     * @param   {String}  className
     * @return  Element
    */


    HSF.prototype.delClassName = function(el, className) {
      return this.removeClassName(el, className);
    };

    /**
     * Получить родителя по тэгу
     * @param   {Element} el
     * @param   {String}  tagName
     * @return  Element|Null
    */


    HSF.prototype.GPT = function(el, tagName) {
      var _ref;
      if ((tagName == null) || tagName === '') {
        return null;
      }
      tagName = tagName.toLowerCase();
      if (!el || !el.parentNode) {
        return null;
      }
      while ((el != null ? (_ref = el.parentNode) != null ? _ref.tagName : void 0 : void 0) != null) {
        el = el.parentNode;
        if (el.tagName.toLowerCase() === tagName) {
          return el;
        }
      }
      return null;
    };

    /**
     * Получить родителя по имени класса
     * @param   {Element} el
     * @param   {String}  className
     * @return  Element|Null
    */


    HSF.prototype.GPC = function(el, className) {
      if (!el) {
        return null;
      }
      if (className !== '') {
        while ((el != null ? el.parentNode : void 0) != null) {
          el = el.parentNode;
          if (this.hasClassName(el, className)) {
            return el;
          }
        }
      } else {
        while ((el != null ? el.parentNode : void 0) != null) {
          el = el.parentNode;
          if (!el.className) {
            return el;
          }
        }
      }
      return null;
    };

    /**
     * Обрезает строку, если она больше и прибавляет к ней многоточие
     * @param   {String}  string
     * @param   {Number}  len
     * @param   {String}  [after] что ставится после обрезанной строки
     * @return  String
    */


    HSF.prototype.truncateStringMin = function(string, len, after) {
      if (after == null) {
        after = '...';
      }
      if (len < string.length) {
        return string.substr(0, len - after.length) + after;
      }
      return string;
    };

    /**
     * Более умное обрезание строки: ищет пробелы в промежутке от dMax до uMax.
     * Если пробел не найден в этом промежутке, то ищет его в меньшую сторону
     * TODO: могут быть не только пробелы, а любые разделяющие символы и при этом скорость не должна упасть
     * @param   {String}  string
     * @param   {Number}  dMax
     * @param   {Number}  uMax
     * @param   {String}  [after]
     * @return  String
    */


    HSF.prototype.truncateString = function(string, dMax, uMax, after) {
      var criticalMinChars, dSpace, i, j, minChars, newStr, uSpace;
      if (after == null) {
        after = '...';
      }
      newStr = "";
      dSpace = -1;
      uSpace = -1;
      minChars = Math.floor(string.length * 0.6);
      criticalMinChars = Math.floor(string.length * 0.35);
      string = string.trim();
      dMax = dMax - after.length;
      uMax = uMax - after.length;
      i = dMax;
      j = dMax;
      while (i < uMax && i < string.length && j >= 0) {
        if (/\W/.test(string.charAt(i)) && dSpace < 0) {
          dSpace = i;
        }
        if (/\W/.test(string.charAt(j)) && uSpace < 0) {
          uSpace = j;
        }
        if (uSpace >= 0 && dSpace >= 0) {
          break;
        }
        i++;
        j--;
      }
      if (string.length < dMax) {
        return string;
      }
      if (dSpace > 0) {
        if (dSpace < minChars) {
          if (uSpace < uMax && uSpace > 0) {
            newStr = string.substr(0, uSpace) + after;
          } else if (dSpace < criticalMinChars) {
            newStr = string.substr(0, dMax) + after;
          } else {
            newStr = string.substr(0, dSpace) + after;
          }
        } else {
          newStr = string.substr(0, dSpace) + after;
        }
      } else if (uSpace > 0) {
        if (uSpace < uMax) {
          newStr = string.substr(0, uSpace) + after;
        } else {
          newStr = string.substr(0, dMax) + after;
        }
      } else {
        if (string.length > dMax && string.length < uMax) {
          newStr = string;
        } else {
          newStr = string.substr(0, dMax) + after;
        }
      }
      return newStr;
    };

    /**
     * получает ширину символа chart размера fs и шрифта ff
     * в кирилице максимальную букву лучше брать Ю
     * @param   {Number} [fs]    =  11
     * @param   {String} [ff]    =  "Tahoma"
     * @param   {String} [chart] =  "m"
     * @return  Number
    */


    HSF.prototype.getCharWidthMax = function(fs, ff, chart) {
      var charEl;
      ff = ff || "Tahoma";
      fs = fs || 11;
      chart = chart || "m";
      if (!window.charWidth) {
        window.charWidth = {};
      }
      if (!(ff in window.charWidth)) {
        window.charWidth[ff] = {};
      }
      if (!(fs in window.charWidth[ff])) {
        charEl = this.GBI("charEl");
        if (!charEl) {
          charEl = this.createElement("#charEl", {
            innerHTML: chart
          }, document.body);
        }
        charEl.style.fontFamily = ff;
        charEl.style.fontSize = fs + "px";
        window.charWidth[ff][fs] = charEl.offsetWidth;
      }
      return window.charWidth[ff][fs];
    };

    /**
     * Добавление сообщения в лог
     * @param   {String}    message
     * @param   {String}    [type] = 'log'
     * @return  Boolean
    */


    HSF.prototype.log = function(message, type) {
      var console, func, str;
      if (type == null) {
        type = 'log';
      }
      str = ((new Date()).getTime() - this._startLogDate).toString();
      this._stackLog[this._stackLog.length] = {
        time: str,
        mess: "" + type + ": " + message
      };
      if ("console" in window) {
        console = window.console;
        switch (type) {
          case 'log':
            func = console.log;
            break;
          case 'info':
            if ('info' in console) {
              func = console.info;
            } else {
              str = 'INFO: ' + str;
            }
            break;
          case 'err':
          case 'error':
            if ('error' in console) {
              func = console.error;
            } else {
              str = "ERROR: " + str;
            }
            break;
          case 'warn':
          case 'warning':
            if ('warn' in console) {
              func = console.warn;
            } else {
              str = "WARN: " + str;
            }
            break;
          case 'debug':
            if ('debug' in console) {
              func = console.debug;
            } else {
              str = "DEBUG: " + str;
            }
            break;
          default:
            str = "" + type + ": " + str;
        }
        if (!func) {
          func = console.log;
        }
        if (typeof func !== "function") {
          func(str + (": " + message));
        } else {
          func.call(console, str + (": " + message));
        }
      } else if (this._debug) {
        alert("" + type + ": " + str + ": " + message);
      }
      return true;
    };

    /**
       * Работает аналогично time в linux: считает кол-во мс, которое тратит на себя функция
       * @param   {String}    message
       * @return  Boolean
    */


    HSF.prototype.time = function(func, renderAfter) {
      var start, t;
      this.log('start time');
      start = (new Date()).getTime();
      func();
      this.log("finish time at " + ((new Date()).getTime() - start) + "ms");
      if (renderAfter === true) {
        this.log('render start');
        start = (new Date()).getTime();
        t = document.body.offsetWidth;
        this.log("finish render at " + ((new Date()).getTime() - start) + "ms");
      }
    };

    /**
     * Выводит лог на экран в виде линии событий и времён
     * TODO: сделать наведение более логичным и не зависящим от общей длины шкалы времени
     * @return Boolean
    */


    HSF.prototype.printLog = function() {
      var height, html, lenTime, n, str, time, timeString, tl, tl0, _i, _j, _len, _ref, _ref1;
      lenTime = 8;
      html = '<table id="printLog" cellpadding="0" cellspacing="0" style="border:0;"><tr><td valign="top" align="left" style="width:40px">';
      tl = '';
      str = '<ul style="font-family:monospace;list-style:none outside none;margin:0;padding:0;">';
      height = 0;
      _ref = this._stackLog;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        time = _ref[_i];
        timeString = "" + time.time;
        for (n = _j = lenTime, _ref1 = timeString.length; lenTime <= _ref1 ? _j <= _ref1 : _j >= _ref1; n = lenTime <= _ref1 ? ++_j : --_j) {
          timeString += '.';
        }
        tl += ("<div id='dotLogPoint" + time + "' onmouseover=\"" + (this.getThis()) + ".selectLogPoint(this);\" onmouseout=\"" + (this.getThis()) + ".unselectLogPoint(this);\" style='position:absolute;right:-4px;top:") + (this.toInt(time) - 4) + "px;border:1px solid #339;border-radius:3px;width:5px;height:5px;cursor:pointer;z-index:1'></div>";
        str += "<li id='textLogPoint" + time + "' onmouseover=\"" + (this.getThis()) + ".selectLogPoint(this);\" onmouseout=\"" + (this.getThis()) + ".unselectLogPoint(this);\" style='cursor:pointer;text-align:left;'><b>" + timeString + ":</b> " + time.mess + "</li>";
        height += 20;
      }
      str += '</ul>';
      tl0 = "<div style='position:relative;border-right:1px solid #339;width:20px;height:" + parseInt(time * 100) + "px'>";
      html += tl0 + tl + ("</div></td><td>" + str + "</td></tr></table>");
      this.createBubble(html, 600, 50, {
        resize: true
      });
      return true;
    };

    /**
     * Выделяет определённую строку при наведении на строчку
     * @param   {Element}  el
     * @return  Boolean
     * @private
    */


    HSF.prototype.selectLogPoint = function(el) {
      var res, secEl;
      res = el.id.match(/(.*)LogPoint(.*)/);
      if (!res) {
        return false;
      }
      if (res[1] === 'dot') {
        secEl = this.GBI("textLogPoint" + res[2]);
        secEl.style.textDecoration = 'underline';
        el.style.backgroundColor = '#f0f';
        el.style.borderColor = '#f0f';
        el.style.zIndex = 10;
      } else {
        secEl = this.GBI("dotLogPoint" + res[2]);
        secEl.style.backgroundColor = '#f0f';
        secEl.style.borderColor = '#f0f';
        secEl.style.zIndex = 10;
        el.style.textDecoration = 'underline';
      }
      return true;
    };

    /**
     * Снимает выделение с определённой строки
     * @param   {Element}  el
     * @return  Boolean
     * @private
    */


    HSF.prototype.unselectLogPoint = function(el) {
      var res, secEl;
      res = el.id.match(/(.*)LogPoint(.*)/);
      if (!res) {
        return false;
      }
      if (res[1] === 'dot') {
        secEl = this.GBI("textLogPoint" + res[2]);
        secEl.style.textDecoration = 'none';
        el.style.backgroundColor = 'transparent';
        el.style.borderColor = '#339';
        el.style.zIndex = 1;
      } else {
        secEl = this.GBI("dotLogPoint" + res[2]);
        secEl.style.backgroundColor = 'transparent';
        secEl.style.borderColor = '#339';
        secEl.style.zIndex = 1;
        el.style.textDecoration = 'none';
      }
      return true;
    };

    /**
     * получает внешнюю обёртку тэга более кроссбраузерно, чем обращение к outerHTML
     * @param {Element} el
     * @return String|Boolean
    */


    HSF.prototype.outerHTML = function(el) {
      return el.outerHTML || ('XMLSerializer' in window && new XMLSerializer().serializeToString(el)) || false;
    };

    /**
     * заполняет спереди нулями number до длины width
     * @param   {Number}  number
     * @param   {Number}  width
     * @return  String
    */


    HSF.prototype.zeroFill = function(number, width) {
      width -= number.toString().length;
      if (width > 0) {
        return new Array(width + (/\./.test(number) ? 2 : 1)).join("0") + number;
      }
      return number + "";
    };

    /**
     * блокирует выполнение действия по умолчанию в браузере, включая такие, как ctrl+s и др.
     * @param {Event} event
     * @return Boolean
    */


    HSF.prototype.blockEvent = function(event) {
      if (event == null) {
        event = window.event;
      }
      if (event.stopPropagation) {
        event.stopPropagation();
      } else {
        event.cancelBubble = true;
      }
      if (event.preventDefault) {
        return event.preventDefault();
      } else {
        return event.returnValue = false;
      }
    };

    /**
     * замещает input полем со стрелочками
     * в опциях можно задать:
     *   step:  {Number} шаг с которым работает колёсико и кнопки
     *   min:   {Number} минимальное значение, ниже которого быть не может
     *   max:   {Number} максимальное значение
     * @param   {Element}   el
     * @param   {Object}    opt
     * @return  Boolean
    */


    HSF.prototype.numberInputReplace = function(el, opt) {
      var check, down, height, inputWrapperReplase, ndn, nup, parent, up, wheel, width,
        _this = this;
      if (opt == null) {
        opt = {};
      }
      width = el.offsetWidth;
      height = el.offsetHeight;
      parent = el.parentNode;
      if (el.tagName.toLowerCase() !== 'input') {
        return false;
      }
      inputWrapperReplase = f.createElement('.inputWrapperReplase', {
        style: {
          width: "" + width + "px",
          height: "" + height + "px",
          position: 'relative',
          display: 'inline-block'
        }
      });
      parent.replaceChild(inputWrapperReplase, el);
      this.appendChild(inputWrapperReplase, el);
      this.appendChild(inputWrapperReplase, "<div class='nup' style='position: absolute; top: 0; right: 0; cursor: pointer; width: 10px; height: 50%;'></div><div class='ndn' style='position: absolute; bottom: 0; right: 0; cursor: pointer; width: 10px; height: 50%;'></div>");
      el.style.width = width - 12 + 'px';
      el.style.height = height - 2 + 'px';
      if (!('step' in opt)) {
        opt.step = 1;
      }
      up = function() {
        var value;
        value = _this.toInt(el.value);
        if ('max' in opt && opt.max < value + opt.step) {
          el.value = opt.max;
        } else {
          el.value = value + opt.step;
        }
        return true;
      };
      down = function() {
        var value;
        value = _this.toInt(el.value);
        if ('min' in opt && opt.min > value - opt.step) {
          el.value = opt.min;
        } else {
          el.value = value - opt.step;
        }
        return true;
      };
      check = function() {
        var value;
        value = _this.toInt(el.value);
        if ('max' in opt && opt.max < value) {
          el.value = opt.max;
        } else if ('min' in opt && opt.min > value) {
          el.value = opt.min;
        }
        return true;
      };
      nup = this.GBC("nup", inputWrapperReplase)[0];
      ndn = this.GBC('ndn', inputWrapperReplase)[0];
      nup.onclick = function(e) {
        if (e == null) {
          e = window.event;
        }
        return up();
      };
      ndn.onclick = function(e) {
        if (e == null) {
          e = window.event;
        }
        return down();
      };
      if (__indexOf.call(nup, 'ondblclick') >= 0) {
        nup.ondblclick = ndn.ondblclick = function() {
          return true;
        };
      }
      wheel = function(e) {
        var num, wheelDelta, _i;
        if (e == null) {
          e = window.event;
        }
        wheelDelta = 0;
        if ('wheelDelta' in e) {
          wheelDelta = e.wheelDelta / 120;
        } else {
          if ('detail' in e) {
            wheelDelta = -e.detail / 3;
          }
        }
        for (num = _i = wheelDelta; wheelDelta <= 0 ? _i <= 0 : _i >= 0; num = wheelDelta <= 0 ? ++_i : --_i) {
          if (num > 0) {
            up();
          } else if (num < 0) {
            down();
          }
        }
        if (e.preventDefault) {
          e.preventDefault();
        }
        e.returnValue = false;
        _this.blockEvent(e);
        return false;
      };
      if ('addEventListener' in el) {
        el.addEventListener('DOMMouseScroll', wheel, false);
      }
      el.onmousewheel = wheel;
      this.addEvent(el, 'change', check);
      return true;
    };

    /**
     * Добавляет слушателя клавиатуры и прерывает действия по умолчанию, если функции не возвращают true
     * @param   {String}    key     название клавиши. См. _keyMap
     * @param   {Function}  func    callback
     * @param   {Boolean}   [ctrl]  =   false
     * @param   {Boolean}   [shift] =   false
     * @param   {Boolean}   [alt]   =   false
     * @return  Boolean
    */


    HSF.prototype.keyListener = function(key, func, ctrl, shift, alt) {
      var keyCode, second;
      if (ctrl == null) {
        ctrl = false;
      }
      if (shift == null) {
        shift = false;
      }
      if (alt == null) {
        alt = false;
      }
      if (typeof func !== 'function') {
        return false;
      }
      second = null;
      if (isNaN(key) || key.toString().length === 1) {
        keyCode = key in this._keyMap ? this._keyMap[key] : key;
      } else {
        keyCode = key;
      }
      if (keyCode === 13 || keyCode === 10) {
        keyCode = 13;
        second = 10;
      } else if ((0 <= key && key <= 9)) {
        second = this._keyMap["numpad" + key];
      }
      if (this.browser().name === 'opera') {
        if ((96 <= keyCode && keyCode <= 105)) {
          keyCode -= 48;
        } else {
          switch (keyCode) {
            case 91:
              keyCode = 219;
              break;
            case 93:
              keyCode = 0;
              break;
            case 106:
              keyCode = 42;
              break;
            case 107:
              keyCode = 43;
              break;
            case 109:
              keyCode = 45;
              break;
            case 110:
              keyCode = 78;
              break;
            case 111:
              keyCode = 47;
              break;
            case 186:
              keyCode = 59;
              break;
            case 187:
              keyCode = 61;
              break;
            case 189:
              keyCode = 109;
          }
        }
      } else if (this.browser().name === 'mozilla') {
        switch (keyCode) {
          case 186:
            keyCode = 59;
            break;
          case 187:
            keyCode = 107;
            break;
          case 189:
            keyCode = 109;
        }
      }
      if (!(keyCode in this._keyListMap)) {
        this._keyListMap[keyCode] = [];
      }
      this._keyListMap[keyCode].push({
        func: func,
        ctrl: ctrl,
        shift: shift,
        alt: alt
      });
      if (second) {
        if (!(second in this._keyListMap)) {
          this._keyListMap[second] = [];
        }
        this._keyListMap[second].push({
          func: func,
          ctrl: ctrl,
          shift: shift,
          alt: alt
        });
      }
      return true;
    };

    /**
     * Добавляет функцию, которая выполнится при наступлении события построения dom модели
     * @param   {Function} func callback
     * @return  Boolean
    */


    HSF.prototype.onDomReady = function(func) {
      var oldonload;
      oldonload = this._funcDomReady;
      if (typeof this._funcDomReady !== "function") {
        this._funcDomReady = func;
      } else {
        this._funcDomReady = function() {
          oldonload();
          return func();
        };
      }
      return true;
    };

    /**
     * Запускает цепочку функций
     * @return *
     * @private
    */


    HSF.prototype.initOnDomReady = function() {
      if (this._ready) {
        return;
      }
      this._ready = true;
      if (this._funcDomReady) {
        return this._funcDomReady();
      }
    };

    /**
     * Подготавливает (расставляет слшателей событий) к загрузке документа
     * @return Boolean
    */


    HSF.prototype.prepareOnDocumentReady = function() {
      var _timer,
        _this = this;
      if (document.addEventListener) {
        document.addEventListener("DOMContentLoaded", function() {
          return _this.initOnDomReady();
        }, false);
      } else if (this.browser().name === 'ie') {
        /*@cc_on @*/
      /*@if (@_win32)
       document.write("<script id=\"__ie_onload\" defer=\"defer\" src=\"javascript:void(0)\"><\/script>");
       var script = document.getElementById("__ie_onload");
       script.onreadystatechange = function() {
       if (this.readyState == "complete")
       f.initOnDomReady();}; // вызываем обработчик для onload
       /*@end @*/;
      } else if (/WebKit/i.test(navigator.userAgent)) {
        _timer = setInterval(function() {
          if (/loaded|complete/.test(document.readyState)) {
            clearInterval(_timer);
            return this.initOnDomReady();
          }
        }, 10);
      } else {
        window.onload = function() {
          return _this.initOnDomReady();
        };
      }
      return true;
    };

    /**
     * Возможность перетаскивания объектов мышью.
     * @param {Element}     element
     * функция проверки принимает 4 аргумента: (element, x/y, 1/0, ev).
     * Если третий аргумент 1, то передаётся x, иначе -- y
     * @param {Function}    funcChecker     функция проверки
     * @param {Function}    funcDragStart   вызывается в начале перетаскивания
     * @param {Function}    funcDragStop    вызывается при окончании перетаскивания (отпускании)
     * @return HSF
    */


    HSF.prototype.setDrag = function(element, opt) {
      var empty, msie, oldOver, sl, st, sx, sy, xy,
        _this = this;
      empty = function() {
        return true;
      };
      xy = function(e, v) {
        if (v) {
          if (msie) {
            return event.clientY + document.body.scrollTop;
          } else {
            return e.pageY;
          }
        } else {
          if (msie) {
            return event.clientX + document.body.scrollTop;
          } else {
            return e.pageX;
          }
        }
      };
      sy = 0;
      sx = 0;
      st = 0;
      sl = 0;
      msie = (this.browser().name === "msie" ? 1 : 0);
      opt = {
        initThis: opt.initThis || false,
        onDragStart: opt.onDragStart || empty,
        onDragEnd: opt.onDragEnd || empty,
        onDragCheckX: opt.onDragCheckX || empty,
        onDragCheckY: opt.onDragCheckY || empty,
        onDragOver: opt.onDragOver || false,
        onDragOut: opt.onDragOut || false,
        onDrop: opt.onDrop || false,
        dragOverCheck: false,
        dropCheck: false
      };
      if (opt.onDragOver || opt.onDragOut) {
        opt.dragOverCheck = true;
        this.setMem(element, 'oldDisplay', element.style.display);
        oldOver = null;
      }
      if (opt.onDrop) {
        opt.dropCheck = true;
      }
      element.ondragstart = function() {
        return false;
      };
      element.onselectstart = function() {
        return false;
      };
      element.onmousedown = function(e) {
        var position, stl, stt, target, touchEnd, touchMove;
        e = e || window.event;
        if (opt.onDragStart(element, e, opt) === false) {
          return false;
        }
        _this.setTempStyle(document.body, {
          cursor: f.getStyle(element, 'cursor')
        }, 'DragStyle');
        target = e.target || e.srcElement;
        target.ondragstart = function() {
          return false;
        };
        if (opt.dragOverCheck) {
          element.style.display = 'none';
          oldOver = document.elementFromPoint(e.pageX || e.clientX, e.pageY || e.clientY);
          element.style.display = _this.getMem(element, 'oldDisplay');
        }
        position = _this.getStyle(element, "position");
        if (position !== "absolute" && position !== "relative") {
          element.style.position = "relative";
        }
        sy = xy(e, 1);
        sx = xy(e, 0);
        if (position === 'relative') {
          stt = 0;
          stl = 0;
        } else {
          stt = element.offsetTop;
          stl = element.offsetLeft;
        }
        st = _this.getStyle(element, "top");
        st = st === 'auto' || st === '' ? stt : _this.toInt(st);
        sl = _this.getStyle(element, "left");
        sl = sl === 'auto' || sl === '' ? stl : _this.toInt(sl);
        document.onmousemove = function(ev) {
          var elOver, x, y;
          if (!ev) {
            ev = window.event;
          }
          y = xy(ev, 1) - sy + st;
          x = xy(ev, 0) - sx + sl;
          if (opt.onDragCheckY(element, y, ev)) {
            element.style.top = y + "px";
          }
          if (opt.onDragCheckX(element, x, ev)) {
            element.style.left = x + "px";
          }
          if (opt.dragOverCheck) {
            element.style.display = 'none';
            elOver = document.elementFromPoint(ev.pageX || ev.clientX, ev.pageY || ev.clientY);
            element.style.display = _this.getMem(element, 'oldDisplay');
            if (oldOver !== elOver) {
              if (opt.onDragOut) {
                opt.onDragOut(oldOver, ev);
              }
              if (opt.onDragOver) {
                opt.onDragOver(elOver, ev);
              }
              oldOver = elOver;
            }
          }
        };
        try {
          touchMove = f.addEvent(document, 'touchmove', document.onmousemove);
        } catch (_error) {}
        document.onmouseup = function(eu) {
          var elOver;
          if (!eu) {
            eu = window.event;
          }
          document.onmousemove = null;
          _this.retTempStyle(document.body, 'DragStyle');
          if (typeof touchMove === 'function') {
            touchMove();
          }
          if (opt.dropCheck) {
            element.style.display = 'none';
            elOver = document.elementFromPoint(eu.pageX || eu.clientX, eu.pageY || eu.clientY);
            element.style.display = _this.getMem(element, 'oldDisplay');
            opt.onDrop(elOver, eu);
          }
          opt.onDragEnd(element, eu);
          document.onmouseup = null;
          if (typeof touchEnd === 'function') {
            touchEnd();
          }
          return true;
        };
        try {
          touchEnd = f.addEvent(document, 'touchend', document.onmouseup);
        } catch (_error) {}
        return false;
      };
      try {
        f.addEvent(element, 'touchstart', element.onmousedown);
      } catch (_error) {}
      return this;
    };

    /**
     * Форматирует дату в строку по шаблону. Все одиночные % должны быть экранированы %%, иначе результат непредсказуем
     *
     * - d день месяца с ведущими нулями 01-31
     * - D день месяца без ведущих нулей 1-31
     * - w день недели  1-7
     * - l Сокращенное наименование дня недели, 2 символа (из настроек) Сб
     * - L Полное наименование дня недели (из настроек) Суббота
     * - m месяц с ведущими нулями
     * - M месяц без ведущих нулей
     * - f Сокращенное наименование месяца, 3 символа (из настроек)
     * - F Полное наименование месяца (из настроек)
     * - Y последние 2 числа года
     * - y год полностью
     * - &nbsp;
     * - a am/pm в нижнем регистре
     * - A AM/PM в верхнем регистре
     * - &nbsp;
     * - g Часы в 12-часовом формате с ведущими нулями
     * - G Часы в 12-часовом формате без ведущих нулей
     * - h Часы в 24-часовом формате с ведущими нулями
     * - H Часы в 24-часовом формате без ведущих нулей
     * - i Минуты с ведущими нулями
     * - I Минуты без ведущих нулей
     * - s секунды с ведущими нулями
     * - S секунды без ведущих нулей
     * - p милисекунды с ведущими нулями
     * - P милисекунды без ведущих нулей
     * - &nbsp;
     * - u количество секунд с началы эпохи юникс (1 января 1970, 00:00:00 GMT)
     * - U количество милисекунд с началы эпохи юникс
     * - &nbsp;
     * - c Дата в формате ISO 8601
     * - r Дата по rfc 2822
     * - O Разница с временем по Гринвичу в часах
     * - z порядковый номер дня
     *
     * @param {Date}    date
     * @param {String}  format
     * @return String
    */


    HSF.prototype.dateToFormat = function(date, format) {
      var percentEcran, t, tmp;
      percentEcran = false;
      if (/%%/.test(format)) {
        percentEcran = true;
        format = format.replace(/%%/g, "'%'");
      }
      if (/%d/.test(format)) {
        t = date.getDate();
        if (t < 10) {
          t = '0' + t;
        }
        format = format.replace(/%d/g, t);
      }
      if (/%D/.test(format)) {
        t = date.getDate();
        format = format.replace(/%D/g, t);
      }
      if (/%w/.test(format)) {
        t = date.getDay() + 1;
        format = format.replace(/%w/g, t);
      }
      if (/%m/.test(format)) {
        t = date.getMonth() + 1;
        if (t < 10) {
          t = '0' + t;
        }
        format = format.replace(/%m/g, t);
      }
      if (/%M/.test(format)) {
        t = date.getMonth() + 1;
        format = format.replace(/%M/g, t);
      }
      if (/%y/.test(format)) {
        t = date.getFullYear();
        format = format.replace(/%y/g, t);
      }
      if (/%Y/.test(format)) {
        t = date.getFullYear().substr(2, 2);
        format = format.replace(/%Y/g, t);
      }
      if (/%a/.test(format)) {
        t = date.getHours();
        t = t > 12 ? 'pm' : 'am';
        format = format.replace(/%a/g, t);
      }
      if (/%A/.test(format)) {
        t = date.getHours();
        t = t > 12 ? 'PM' : 'AM';
        format = format.replace(/%A/g, t);
      }
      if (/%c/.test(format)) {
        t = date.toISOString();
        format = format.replace(/%c/g, t);
      }
      if (/%l/.test(format)) {
        t = this._dateNames.weekShort[date.getDay()];
        format = format.replace(/%l/g, t);
      }
      if (/%L/.test(format)) {
        t = this._dateNames.weekFull[date.getDay()];
        format = format.replace(/%L/g, t);
      }
      if (/%f/.test(format)) {
        t = this._dateNames.monthShort[date.getMonth()];
        format = format.replace(/%f/g, t);
      }
      if (/%F/.test(format)) {
        t = this._dateNames.monthFull[date.getMonth()];
        format = format.replace(/%F/g, t);
      }
      if (/%g/.test(format)) {
        t = date.getHours();
        if (t > 12) {
          t -= 12;
        }
        format = format.replace(/%g/g, t);
      }
      if (/%G/.test(format)) {
        t = date.getHours();
        if (t > 12) {
          t -= 12;
        }
        if (t < 10) {
          t = '0' + t;
        }
        format = format.replace(/%G/g, t);
      }
      if (/%h/.test(format)) {
        t = date.getHours();
        if (t < 10) {
          t = '0' + t;
        }
        format = format.replace(/%h/g, t);
      }
      if (/%H/.test(format)) {
        t = date.getHours();
        format = format.replace(/%H/g, t);
      }
      if (/%i/.test(format)) {
        t = date.getMinutes();
        if (t < 10) {
          t = '0' + t;
        }
        format = format.replace(/%i/g, t);
      }
      if (/%I/.test(format)) {
        t = date.getMinutes();
        format = format.replace(/%I/g, t);
      }
      if (/%s/.test(format)) {
        t = date.getSeconds();
        if (t < 10) {
          t = '0' + t;
        }
        format = format.replace(/%s/g, t);
      }
      if (/%S/.test(format)) {
        t = date.getSeconds();
        format = format.replace(/%S/g, t);
      }
      if (/%p/.test(format)) {
        t = date.getMilliseconds();
        if (t < 10) {
          t = '00' + t;
        } else if ((10 <= t && t < 100)) {
          t = '0' + t;
        }
        format = format.replace(/%p/g, t);
      }
      if (/%P/.test(format)) {
        t = date.getMilliseconds();
        format = format.replace(/%P/g, t);
      }
      if (/%r/.test(format)) {
        t = this.dateToFormat(date, '%l, %d %f %y %h:%i:%s %O');
        format = format.replace(/%r/g, t);
      }
      if (/%O/.test(format)) {
        t = date.toString();
        t = t.substr(t.indexOf('+'));
        format = format.replace(/%O/g, t);
      }
      if (/%u/.test(format)) {
        t = date.getTime();
        t = (t - (t % 1000)) / 1000;
        format = format.replace(/%u/g, t);
      }
      if (/%U/.test(format)) {
        t = date.getTime();
        format = format.replace(/%U/g, t);
      }
      if (/%z/.test(format)) {
        t = date.getTime();
        tmp = new Date(t);
        tmp.setMonth(0);
        tmp.setDate(1);
        tmp.setHours(0);
        tmp.setMinutes(0);
        tmp.setSeconds(0);
        tmp.setMilliseconds(0);
        t = Math.floor((t - tmp.getTime()) / 86400000);
        format = format.replace(/%z/g, t);
      }
      if (percentEcran === true) {
        format = format.replace(/'%'/g, '%');
      }
      return format;
    };

    /**
     * Вставляет элемент el после элемента exist
     * @param   {Node} el который вставляем
     * @param   {Node} exist после которого вставляем
     * @return  Node
    */


    HSF.prototype.insertAfter = function(el, exist) {
      var next, parent;
      parent = exist.parentNode;
      next = exist.nextSibling;
      if (next) {
        parent.insertBefore(el, next);
      } else {
        parent.appendChild(el);
      }
      return this;
    };

    /**
     * Вставляет элемент el перед элементом exist
     * @param   {Node} el который вставляем
     * @param   {Node} exist перед которым вставляем
     * @return  Node
    */


    HSF.prototype.insertBefore = function(el, exist) {
      exist.parentNode.insertBefore(el, exist);
      return this;
    };

    /**
     * Получает рендомное число от min до max включительно
     * @param   {Number} min минимальное значение
     * @param   {Number} max максимальное значение
     * @return  Number
    */


    HSF.prototype.random = function(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };

    /**
       * Замена jQuery селектору и универсализация querySelectorAll
       * @param   {String} queryString селектор
       * @param   {Element} context = document контекст, в котором ищем
       * @return  Array
    */


    HSF.prototype.qsa = function(queryString, context) {
      var a, beh, c, i, j, r, s, script, selector, _i, _j, _len, _len1, _ref;
      if (context == null) {
        context = document;
      }
      if ('querySelectorAll' in context) {
        return [].take(context.querySelectorAll(queryString));
      }
      if ('jQuery' in window) {
        return jQuery(queryString, context).get();
      }
      s = document.createStyleSheet();
      r = queryString.replace(/\[for\b/gi, "[htmlFor").split(",");
      window.hsfSelectorCollection = [];
      if (this._scriptPath === '') {
        _ref = this.GBT('script');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          script = _ref[_i];
          if (/hsf\.(min\.|dev\.)?js$/.test(script.src || '')) {
            this._scriptPath = script.src.replace(/hsf\.(min\.|dev\.)?js$/, '');
            break;
          }
        }
        if (this._scriptPath === '') {
          this._scriptPath = false;
        }
      }
      if (this._scriptPath === false) {
        a = context.all;
        c = [];
        i = r.length;
        while (i--) {
          s.addRule(r[i], "k:v");
          j = a.length;
          while (j--) {
            a[j].currentStyle.k && c.push(a[j]);
          }
          s.removeRule(0);
        }
        return c;
      } else {
        beh = this._scriptPath + '/ca.htc';
        for (_j = 0, _len1 = r.length; _j < _len1; _j++) {
          selector = r[_j];
          s.addRule(selector, "behavior: url(" + beh + ")");
          s.removeRule(0);
        }
        s.owningElement.parentNode.removeChild(s.owningElement);
        return window.hsfSelectorCollection;
      }
    };

    /**
     * Получение ширины скроллбара. Взято из MooTools
     * @return  Number
    */


    HSF.prototype.getScrollBarWidth = function() {
      var inner, outer, w1, w2;
      if (this._scrollBarWidth < 0) {
        this.appendChild(document.body, "<div id='__HSFscrollbar' style='position:absolute;top:0;left:0;visibility:hidden;width:200px;height:150px;overflow:hidden;'><p style='width:100%;height:200px'></p></div>");
        outer = f.GBI('__HSFscrollbar');
        inner = outer.children[0];
        w1 = inner.offsetWidth;
        outer.style.overflow = "scroll";
        w2 = inner.offsetWidth;
        if (w1 === w2) {
          w2 = outer.clientWidth;
        }
        document.body.removeChild(outer);
        this._scrollBarWidth = w1 - w2;
      }
      return this._scrollBarWidth;
    };

    /**
     * преобразует данные формы в строку. Нет типа файл из-за проблем с кроссбраузерностью
     * @param {HTMLFormElement} form форма
     * @param {Boolean} isGet является ли запрос get-запросом
     * @return  String
    */


    HSF.prototype.formToData = function(form, isGet) {
      var el, encodeEl, p, q, _i, _len, _ref;
      q = '';
      p = isGet ? '?' : '';
      encodeEl = function(el) {
        var r;
        r = p + encodeURI(el.name) + '=' + encodeURI(el.value);
        p = '&';
        return r;
      };
      if (form.elements.length === 0) {
        return false;
      }
      _ref = form.elements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        el = _ref[_i];
        switch (el.type) {
          case "select-one":
          case "select":
          case "password":
          case "textarea":
          case "hidden":
          case "text":
            q += encodeEl(el);
            break;
          case "radio":
          case "checkbox":
            if (el.checked) {
              q += encodeEl(el);
            }
            break;
        }
      }
      return q;
    };

    /**
     * Создаёт системный стиль. Если количество стилей зашкаливает (31+), то приклеивается к последнему стилю.
     * @return  HSF
    */


    HSF.prototype.createStyleSheet = function() {
      var ss;
      if (this._systemStyleSheet != null) {
        return this;
      }
      this._CSSCache = {
        index: {},
        rules: []
      };
      if (document.styleSheets.length > 30) {
        this._systemStyleSheet = ss;
        this.updateStyleSheetIndex();
      } else {
        if ('createStyleSheet' in document) {
          ss = document.createStyleSheet();
          this.appendChild(document.body, ss.owningElement);
        } else {
          ss = f.createElement('style', {}, document.body).sheet;
        }
        this._systemStyleSheet = ss;
      }
      return this;
    };

    /**
     * Обновляет индекс стилей или создаёт его
     * @return  HSF
    */


    HSF.prototype.updateStyleSheetIndex = function() {
      var cssText, i, indexStyle, mode, p, part, rule, rules, selectorText, sumaryStyle, _i, _j, _k, _len, _len1, _len2, _ref;
      sumaryStyle = [];
      indexStyle = {};
      mode = -1;
      rules = this._systemStyleSheet.cssRules || this._systemStyleSheet.rules;
      for (_i = 0, _len = rules.length; _i < _len; _i++) {
        rule = rules[_i];
        if (!('style' in rule)) {
          continue;
        }
        cssText = rule.style.cssText;
        if (cssText.indexOf('{') >= 0 && cssText.charAt(cssText.length - 1) === '}') {
          mode = 1;
        } else {
          mode = 0;
        }
        break;
      }
      for (i = _j = 0, _len1 = rules.length; _j < _len1; i = ++_j) {
        rule = rules[i];
        selectorText = rule.selectorText;
        if (!('style' in rule)) {
          indexStyle[selectorText] = i;
          sumaryStyle[i] = {};
          continue;
        }
        indexStyle[selectorText.replace(/(^| |\+|>|~|,)[A-Z]+/g, function(c) {
          return c.toLowerCase();
        })] = i;
        if (!(selectorText in sumaryStyle)) {
          sumaryStyle[i] = {};
        }
        cssText = rule.style.cssText;
        if (mode === 1) {
          cssText = cssText.substr(0, cssText.length - 1).substr(cssText.indexOf('{') + 1).trim();
        }
        _ref = cssText.split(';');
        for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
          part = _ref[_k];
          p = part.indexOf(':');
          if (p === -1) {
            continue;
          }
          sumaryStyle[i][part.substr(0, p).trim().toLowerCase()] = part.substring(p + 1, part.length).trim();
        }
        this._CSSCache.rules = sumaryStyle;
        this._CSSCache.index = indexStyle;
      }
      return this;
    };

    /**
     * Устанавливает новое CSS правило
     * Если правило существует, то оно дополняется свойствами из prop или prop: value, при чём, если prop строка, а value не указан, будет ошибка
     * Формат prop как строки "-moz-border-radius" или "MozBorderRadius", но правильный первый вариант
     * Формат prop как объекта {"-moz-border-radius": "5px"} или {MozBorderRadius: "5px"}, но правильный первый вариант
     * value только строка и учитывается только, когда prop строка
     * @param {String} selector селектор, имена тегов в нижнем регистре. Иначе поведение непредопределено.
     * @param {String|Object} prop название свойства или объект свойств
     * @param {String|NULL} [value] = null значение
     * @return  HSF
    */


    HSF.prototype.setCSS = function(selector, prop, value) {
      var eProps, i, newIndex, p, pp, props, reIndexed, rule, rules, sel, selectors, strProps, v, _i, _j, _len, _len1;
      selectors = selector.split(',');
      props = {};
      switch (typeof prop) {
        case 'string':
          if (value == null) {
            this.log('setCSS: value не задана', 'error');
            return this;
          }
          prop = prop.replace(/[A-Z]/g, function(c) {
            return '-' + c.toLowerCase();
          });
          props[prop] = value;
          break;
        case 'object':
          for (p in prop) {
            if (!__hasProp.call(prop, p)) continue;
            value = prop[p];
            p = p.replace(/[A-Z]/g, function(c) {
              return '-' + c.toLowerCase();
            });
            props[p] = value;
          }
          break;
        default:
          this.log('setCSS: Неизвестный тип prop', 'error');
          return this;
      }
      if (this._CSSCache == null) {
        this.createStyleSheet();
      }
      rules = this._systemStyleSheet.cssRules || this._systemStyleSheet.rules;
      reIndexed = false;
      if (this._CSSCache.rules.length !== rules.length) {
        reIndexed = true;
      } else {
        for (_i = 0, _len = selectors.length; _i < _len; _i++) {
          sel = selectors[_i];
          sel = sel.trim();
          if (sel in this._CSSCache.index) {
            rule = rules[this._CSSCache.index[sel]];
            if (rule.selectorText.replace(/(^| |\+|>|~|,)[A-Z]+/g, function(c) {
              return c.toLowerCase();
            }) !== sel) {
              reIndexed = true;
              break;
            }
          }
        }
      }
      if (reIndexed) {
        this.updateStyleSheetIndex();
        this.log('index is crash', 'warn');
      }
      strProps = '';
      for (_j = 0, _len1 = selectors.length; _j < _len1; _j++) {
        sel = selectors[_j];
        sel = sel.trim();
        i = this._CSSCache.index[sel];
        if (i == null) {
          newIndex = this._CSSCache.rules.length;
          if (this._systemStyleSheet.addRule) {
            this._systemStyleSheet.addRule(sel, 'abc: dev;', newIndex);
          } else {
            this._systemStyleSheet.insertRule("" + sel + " {}", newIndex);
          }
          this._CSSCache.rules[newIndex] = {};
          this._CSSCache.index[sel] = newIndex;
          i = newIndex;
        }
        rule = rules[i];
        eProps = this._CSSCache.rules[i];
        for (p in eProps) {
          if (!__hasProp.call(eProps, p)) continue;
          v = eProps[p];
          if (p in props) {
            pp = props[p];
            if (pp !== null) {
              strProps += "" + p + ": " + pp + "; ";
              eProps[p] = pp;
              delete props[p];
            } else {
              delete eProps[p];
            }
          } else {
            strProps += "" + p + ": " + v + "; ";
          }
        }
        for (p in props) {
          if (!__hasProp.call(props, p)) continue;
          v = props[p];
          strProps += "" + p + ": " + v + "; ";
          eProps[p] = v;
        }
        rule.style.cssText = strProps;
      }
      return this;
    };

    /**
     * Удалает CSS правило из системного styleSheet-та по селектору
     * @param {String} selector селектор, имена тегов в нижнем регистре. Иначе поведение непредопределено.
     * @return  HSF
    */


    HSF.prototype.remCSS = function(selector) {
      var i, reIndexed, rule, rules, sel, selectors, _i, _j, _len, _len1;
      if (this._systemStyleSheet == null) {
        return this;
      }
      selectors = selector.split(',');
      rules = this._systemStyleSheet.cssRules || this._systemStyleSheet.rules;
      reIndexed = false;
      if (this._CSSCache.rules.length !== rules.length) {
        reIndexed = true;
      } else {
        for (_i = 0, _len = selectors.length; _i < _len; _i++) {
          sel = selectors[_i];
          if (sel in this._CSSCache.index) {
            rule = rules[this._CSSCache.index[sel]];
            if (rule.selectorText.replace(/(^| |\+|>|~|,)[A-Z]+/g, function(c) {
              return c.toLowerCase();
            }) !== sel) {
              reIndexed = true;
              break;
            }
          }
        }
      }
      if (reIndexed) {
        this.updateStyleSheetIndex();
        this.log('index is crash', 'warn');
      }
      for (_j = 0, _len1 = selectors.length; _j < _len1; _j++) {
        sel = selectors[_j];
        i = this._CSSCache.index[sel];
        if (i == null) {
          continue;
        }
        if ('deleteRule' in this._systemStyleSheet) {
          this._systemStyleSheet.deleteRule(i);
        } else {
          this._systemStyleSheet.removeRule(i);
        }
        this._CSSCache.rules.del(i);
        delete this._CSSCache.index[sel];
      }
      return this;
    };

    return HSF;

  })();

  if ('localStorage' in window) {
    HSF.prototype.setLS = function(key, val) {
      var e;
      try {
        localStorage.setItem(key, val);
      } catch (_error) {
        e = _error;
        return e;
      }
      return true;
    };
    HSF.prototype.getLS = function(key) {
      return localStorage.getItem(key);
    };
    HSF.prototype.delLS = function(key) {
      return localStorage.removeItem(key);
    };
    HSF.prototype.clearLS = function() {
      return localStorage.clear();
    };
  } else if (HSF.prototype.browser().name === 'msie') {
    HSF.prototype._initIeStorage = function() {
      this._storage = this.createElement('div#__storageElement', {
        style: {
          display: 'none'
        }
      }, document.body);
      if (!this._storage.addBehavior) {
        this.log('Нет поддержки userDara');
      } else {
        this._storage.addBehavior("#default#userData");
        this._storage.load('hsf');
      }
      return this;
    };
    HSF.prototype.setLS = function(key, value) {
      this._storage.setAttribute(key, value);
      this._storage.save("hsf");
      return this;
    };
    HSF.prototype.getLS = function(key) {
      return this._storage.getAttribute(key);
    };
    HSF.prototype.delLS = function(key) {
      this._storage.removeAttribute(key);
      this._storage.save("hsf");
      return this;
    };
    HSF.prototype.clearLS = function() {
      var v, _i, _len, _ref;
      _ref = this._storage.XMLDocument.documentElement.attributes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        this.delLS(v.name);
      }
      return this;
    };
  } else {
    HSF.prototype.setLS = function() {
      return this;
    };
    HSF.prototype.getLS = function() {
      return null;
    };
    HSF.prototype.delLS = function() {
      return this;
    };
    HSF.prototype.clearLS = function() {
      return this;
    };
  }

  window.f = new HSF({
    counter: false
  });

}).call(this);

/*
//@ sourceMappingURL=hsf.map
*/
